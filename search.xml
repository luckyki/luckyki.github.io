<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pyc]]></title>
    <url>%2F2018%2F03%2F28%2Fpyc%2F</url>
    <content type="text"><![CDATA[python源码具有以下三条特性 源码距离底层更远（根据官方文档的解释。不说，你们也感觉得到）(。・`ω´・) 运行时都需要生成字节码，交由虚拟机执行。（你们问我虚拟机在哪儿？！你们也不看看各自都是用什么软件执行的！没错，就是解释器，别和我说是IDLE啊。虚拟机具体实现了由switch-case语句构成的框架函数PyEval_EvalFrameEx，刚刚说的字节码就是这货执行的） 每次执行脚本，虚拟机总要多出加载和链接的流程。（所以呢，相比于编译型语言就有点慢了。这与“有丝分裂间期”一样，准备东西也要花时间啊！） 虚拟机它是怎么执行python脚本的： 完成模块的加载和链接； 将源代码翻译为PyCodeObject对象（这货就是字节码），并将其写入内存当中（方便CPU读取，起到加速程序运行的作用）； 从上述内存空间中读取指令并执行； 程序结束后，根据命令行调用情况（即运行程序的方式）决定是否将PyCodeObject写回硬盘当中（也就是直接复制到.pyc或.pyo文件中）； 之后若再次执行该脚本，则先检查本地是否有上述字节码文件。有则执行，否则重复上述步骤 关于.pyc与.pyo.pyc文件是由.py文件经过编译后生成的字节码文件，其加载速度相对于之前的.py文件有所提高，而且还可以实现源码隐藏，以及一定程度上的反编译。比如，Python3.3编译生成的.pyc文件，Python3.4就别想着去运行啦！→_→ .pyo文件也是优化（注意这两个字，便于后续的理解）编译后的程序（相比于.pyc文件更小），也可以提高加载速度。但对于嵌入式系统，它可将所需模块编译成.pyo文件以减少容量。 手动生成.pyc文件如下格式运行.py文件来生成.pyc文件 1234import py_compile#同样也可以是包含.py文件的目录路径 #此处尽可能使用raw字符串，从而避免转义的麻烦。比如，这里不加“r”的话，你就得对斜杠进行转义py_compile.compile(r'/path/to/需要生成.pyc的脚本.py')]]></content>
  </entry>
  <entry>
    <title><![CDATA[DuerOS]]></title>
    <url>%2F2018%2F03%2F26%2FDuerOS%2F</url>
    <content type="text"><![CDATA[DuerOS-Pythonubuntu16.04 32位 首先要感谢大神提供SDK,传递了知识。 在此记录一下使用经历 1、首先是需要一个物理机的ubuuntu16.04环境，系统本身带有Python2.7.12. 2、安装Python程序运行时的各种依赖 123456$ apt-get install gstreamer1.0 #安装gstreamer1.0。gstreamer是一个基于流水线的多媒体框架。可以创建诸如视屏编辑、流媒体广播和媒体播放器等多媒体应用。$ apt-get gstreamer1.0-plugins-good$ apt-get gstreamer1.0-plugins-ugly$ apt-get python-gi$ apt-get python-gst$ apt-get python gir1.2-gstreamer-1.0 #如遇无法定位软件包问题，可需改etc/apt/source.list文件 3、下载代码到本地（可以下载压缩包或者git clone） 4、注册百度账号并完成开发者验证 5、运行授权脚本（此过程中可能会提示ImportError,按照提示，pip install xx包） 6、运行Enter键唤醒模式（运行） 7、运行语音”小度小度”触发唤醒模式 8、更换唤醒词 在snowboy训练唤醒词并下载模型;下载snowboy源码，编译源码；替换SDK中的snowboy文件夹并修改相关文件。 下载源码 解压 ./configure –prefix = /usr/local/swig3.0.12 #在解压文件夹下配置 make #编译 sudo make install #安装 sudo vim /etc/profile #配置path 在文末添加PATH=/usr/local/swig3.0.12/bin:$PATH]]></content>
  </entry>
  <entry>
    <title><![CDATA[验证码识别]]></title>
    <url>%2F2018%2F03%2F20%2F%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[win10环境下python版libsvm安装 win10(64-bit) + python3.6.0(64-bit) 配置libsvm-3.22 libsvm for python使用 libsvm安装主要是配置libsvm.dll文件（可以vs编译或者python安装轮子生成.dll文件） win10 vs2010安装教程 识别流程字符型图片验证码识别完整过程及python实现 1、获取验证码素材图片 2、图片预处理（读取图片转化为二值化的黑白图片，去除背景噪点） 3、图片字符切割 4、图片尺寸归一化 5、图片字符标记 6、字符图片特征提取 7、生成特征和标记对应的训练数据集 8、训练特征标记数据生成识别模型 9、使用识别模型预测新的未知图片集 10、达到根据“图片”就能返回识别正确的字符集的目标]]></content>
  </entry>
  <entry>
    <title><![CDATA[字符编码]]></title>
    <url>%2F2018%2F03%2F17%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[前言&#160; &#160; &#160; &#160;众所周知，在计算机的世界，所有的信息都是0/1组合的二进制序列，计算机是无法直接识别和存储字符的。因此，字符必须经过编码才能被计算机处理。字符编码是计算机技术的基础，也是程序猿/媛需要的基本功之一。 &#160; &#160; &#160; &#160;在展开具体介绍之前，首先要强调一下几个概念，这对理解字符编码非常重要，也将贯穿在后文的介绍之中： 1)理解字符集和字符编码的区别2)“系统/终端/文件/程序”不同概念上的编码3)常见操作系统、文本编辑器对字符编码的处理 1、字符集与字符编码&#160; &#160; &#160; &#160;如前所述，字符只有按照一定规则编码，最终表示为0/1二进制序列的形式，才能被计算机处理。那么，怎么定义这种编码映射呢？其实很简单，只要大家都按照相同的规则，规定好字符与二进制序列（表现为某个数值）之间的对应关系即可。比如，我们规定英语大写字母A对应数字65，那么我们只要将65的二进制形式（01000001）保存即可。 &#160; &#160; &#160; &#160;那么，问题又来了。如果大家使用的规则不一致怎么办，那岂不全乱套了？这时候，字符集就粉墨登场了。所谓字符集，直观上讲，就是人们统计预先规定好的一系列字符与二进制序列（数字）之间的映射关系。只要大家都遵循这个规则，并且计算机也按照这种方式处理，那么这个世界不就很美好了！然而，全世界的语言实在太多了，由于历史和地域的原因，也就形成了多套应用于不同场合、语言的字符集，如ASCII、GBK、Unicode等。&#160; &#160; &#160; &#160;需要注意的是，我们规定好了字符与数字之间的对应关系，但这并不代表计算机一定要按照字符对应的数字将数字本身直接存储！有时候，我们按照一定的规则，将字符的码元再次处理，以更加适应计算机存储、网络传输的需要。字符编码便是规定了如何编码、存储这些字符对应的二进制序列。&#160; &#160; &#160; &#160;因此，某种意义上，可以理解为，字符集是一种协议，而字符编码是对字符集的一种实现。当然，既然称之为“实现”，也说明对同一种字符集可能有不同的编码方式。可以想到，最直接的编码方式，便是直接使用字符对应的二进制序列，这就导致了字符集和字符编码看起来像是一个东东，长期受此思维影响，可能就会对Unicode和UTF的区别有些困惑。 2 、祖先：ASCII编码&#160; &#160; &#160; &#160;再次回顾，在计算机内部，所有的信息最终都表示为一个二进制的序列。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256（2^8）种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态可以对应一个符号，就是256个符号，从0000_0000到1111_1111。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定，这是ASCII（American Standard Code for Information Interchange，美国信息交换标准代码），一直沿用至今。 &#160; &#160; &#160; &#160;ASCII码一共规定了128个字符的编码，包含常见的英语字符和一些控制符号。比如空格（Space）对应32（二进制0010_0000），大写字母A对应65（二进制0100_0001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0，没有使用。&#160; &#160; &#160; &#160;需要强调的是，ASCII便是字符集与字符编码相同的情况，直接将字符对应的8位二进制数作为最终形式存储。因此，当我们提及ASCII，既表示了一种字符集，也代表了一种字符编码，即常说的“ASCII编码”。 ACIII表如下图所示 3 、扩展：扩展ASCII&#160; &#160; &#160; &#160;英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。同时，1byte中我们不是还有最高位没有使用么？这能够再编码128个符号啊！ &#160; &#160; &#160; &#160;于是，一些欧洲国家就决定，利用闲置的最高位编入新的符号。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。从128到255这些字符集被称“扩展字符集”。 &#160; &#160; &#160; &#160;基于此，ISO 组织在ASCII码基础上又制定了一系列标准用来扩展ASCII编码，它们是ISO-8859-1~ISO-8859-15，其中ISO-8859-1（又称Latin-1）涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1仍然是单字节编码，它总共能表示256个字符。但是，问题又来了。。。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。但是不管怎样，所有这些编码方式中，0-127表示的符号是一样的，不一样的只是多了128-255的这一段，因此它们都向下兼容ASCII编码。同样，对于扩展ASCII，它也是既表示了字符集，也代表一种字符编码。 4 、中文：GB系列&#160; &#160; &#160; &#160;字符型语言的字符数量较少，因此用一个byte（8bit）基本就够用了，这就难为了我们博大精深的中文汉字——中文常用字就有好几千呢！但这也难不倒我们勤劳勇敢的中国人，为此，我们设计了GB2312字符集，意气风发走进那新时代。&#160; &#160; &#160; &#160;GB2312的思想其实很简单——既然1个byte不够用，那咱们用2个呀！正所谓，“没有1byte解决不了的问题，如果有，就2byte”。理论上，2个字节便可以表示2^16=65536的字符。不过，GB2312最初被设计时，只规定了中文常见字，很多特殊字符还没有包含。GB2312一共收录了7445个字符，包括6763个汉字和682个其它符号。除了GB2312，还有用于中文繁体的Big5。&#160; &#160; &#160; &#160;人们逐渐发现，GB2312规定的字符太少，甚至有些国家领导人名字中的汉字都表示不出来，这还了得！于是1995年的汉字扩展规范GBK1.0（《汉字内码扩展规范》）收录了21886个符号，它分为汉字区和图形符号区。GBK编码是GB2312编码的超集，向下完全兼容GB2312，同时GBK收录Unicode基本多文种平面中的所有CJK汉字。GBK还收录了GB2312不包含的汉字部首符号、竖排标点符号等字符。&#160; &#160; &#160; &#160;2000年的GB18030是取代GBK1.0的正式国家标准。GB18030编码向下兼容GBK和GB2312。GB18030收录了所有Unicode3.1中的字符，包括中国少数民族字符。GB18030虽然是国家标准，但是实际应用系统中使用的并不广泛。目前使用最广的仍是GBK编码。&#160; &#160; &#160; &#160;GBK和GB2312都是双字节等宽编码，如果算上为与ASCII兼容所支持的单字节，也可以理解为是单字节和双字节混合的变长编码。GB18030编码是变长编码，采用单字节、双字节和4字节方案，其中单字节、双字节和GBK是完全兼容的，4字节编码的码位就是收录了CJK扩展A的6582个汉字。 从ASCII、GB2312、GBK到GB18030，这些编码方法是向下兼容的，即同一个字符在这些方案中总是有相同的编码，后面的标准支持更多的字符。在这些编码中，英文和中文可以统一地处理，区分中文编码的方法是高字节的最高位不为0。GB2312、GBK都属于双字节字符集 (DBCS)。最后，不严格的说，GB系列编码也可以认为是具有字符集的意义，又有字符编码的意义。实际上，GB系列编码中有“区位码”的概念（由于采用两个数来编码汉字和中文符号。第一个数称为“区”，第二个数称为“位”，所以也称为区位码），实际上， 区位码更应该认为是字符集的定义，定义了所收录的字符和字符位置，而GB2312是实际计算机环境中支持这种字符集的编码。区位码和GB2312编码的关系有点像Unicode和UTF-8，正是最开始介绍的字符集与字符编码的区分。 5、 统一：Unicode介绍完ASCII、Latin和GBK，想必各位会有这样的想法：为什么不规定一种字符集、编码方式，直接能够囊括全世界所有语言文字的符号呢？由于科技发展不同步等历史原因，多种编码方式并存是不可避免的现象，但大一统的工作实际上人们也在做，这就是大名鼎鼎的Unicode。这里面也有段有趣的历史。实际上，最早是由两个独立的组织都在设计一种通用字符集，但两家很快意识到，这个世界并不需要两套不同的通用字符集存在，否则所谓的“通用”便失去了意义。于是，后期的Unicode工作被有组织的统一了起来。Unicode是为了整合全世界的所有语言文字而诞生的，全称是Universal Multiple-Octet Coded Character Set，它所规定的字符集也被称为Universal Character Set (UCS)。再次提醒，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。也即，UCS规定了怎么用多个字节表示各种文字，而怎样存储、传输这些编码，则是由UTF (UCSTransformation Format)规范规定的。UTF会在后文介绍。 5.1 UCSUCS有两种不同的规定版本：UCS-2和UCS-4。顾名思义，UCS-2就是用2个字节编码，UCS-4就是用4个字节（实际上只用了31位，最高位必须为0）编码。因此，UCS-2有2^16=65536个码位，UCS-4有2^31=2147483648个码位。目前UCS-2已经足够用了，UCS-4估计都可以把Asgard和氪星的文字（传说都是英语？）也收录进来了……具体的符号对应表，可以查询unicode.org，或者相关的字符对应表。UCS-4根据最高位为0的最高字节分成 =128个Group，每个Group再根据次高字节分为256个Plane，每个Plane根据第3个字节分为256行 (Rows)，每行包含256个Cells。同一行的Cells只是最后一个字节不同，其余都相同。 其中，Group 0的Plane 0被称作Basic MultilingualPlane，即BMP，或者说UCS-4中，高两个字节为0的码位被称作BMP。将UCS-4的BMP去掉前面的两个零字节就得到了UCS-2。在UCS-2的两个字节前加上两个零字节，就得到了UCS-4的BMP。而目前的UCS4规范中还没有任何字符被分配在BMP之外。那么，新的问题又来了：1)如何才能区别Unicode和ASCII？计算机怎么知道2个字节表示1个符号，而不是分别表示2个符号呢？2)我们已经知道，英文字母只用1个字节表示就够了(ASCII)，如果Unicode统一规定，每个符号用2个或4个字节表示，那么每个英文字母前都必然有许多字节是0，这对于存储来说是极大的浪费，是无法接受的。这些问题造成的结果是：1)出现了Unicode的多种存储方式，也就是说有许多种不同的格式，可以用来表示Unicode。2)Unicode在很长一段时间内无法推广，直到互联网（UTF-8）的出现。 5.2 UTFUTF（Unicode/UCSTransformation Format），即Unicode字符集的编码标准，可以理解为对Unicode字符集的具体使用/实现方式，主要有UTF-16、UTF-32和UTF-8。 UTF-16UTF-16由RFC2781协议规定，它使用2个字节来表示1个字符。不难猜到，UTF-16是完全对应于UCS-2的（实际上稍有区别），即把UCS-2规定的代码点通过Big Endian（下文介绍）或Little Endian方式直接保存下来。UTF-16包括三种：UTF-16，UTF-16BE（Big Endian），UTF-16LE（Little Endian）。UTF-16BE和UTF-16LE不难理解，而UTF-16就需要通过在文件开头以名为BOM（Byte Order Mark，下文介绍）的字符来表明文件是Big Endian还是Little Endian。BOM为\uFEFF这个字符。其实BOM是个小聪明的想法。由于UCS-2没有定义\uFFFE，因此只要出现 FF FE 或者 FE FF 这样的字节序列，就可以认为它是\uFEFF，并且据此判断出是Big Endian还是Little Endian。例：“ABC”这三个字符用各种方式编码后的结果如下： 另外，UTF-16还能表示一部分的UCS-4字符——\u10000～\u10FFFF，表示算法就不再详细介绍了。总结来说，UTF-16以2、4字节存储一个Unicode编码，对于小于0x10000的UCS码，UTF-16编码就等于UCS码对应的16位无符号整数。对于不小于0x10000的UCS码，定义了一个算法。不过由于实际使用的UCS2，或者UCS4的BMP必然小于0x10000，所以就目前而言，可以认为UTF-16和UCS-2基本相同（前提是明白UTF和UCS的差别）。 UTF-32UTF-32用4个字节表示字符，这样就可以完全表示UCS-4的所有字符，而无需像UTF-16那样使用复杂的算法。与UTF-16类似，UTF-32也包括UTF-32、UTF-32BE、UTF-32LE三种编码，UTF-32也同样需要BOM字符。以“ABC”为例。 UTF-16和UTF-32的一个缺点就是它们固定使用2个或3个字节，这样在表示纯ASCII文件时会有很多零字节，造成浪费。RFC3629定义的UTF-8则解决了这个问题，下面介绍UTF-8。 UTF-8随着互联网的普及，强烈要求出现一种统一的编码方式，UTF-8就是在互联网上使用最广的一种Unicode的实现（传输）方式。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1-4个字节表示一个符号，根据不同的符号而变化字节长度。为什么采用边长的机制，实际上和字符出现的概率分布有关，其中蕴含着Huffman编码的思想——最常出现的字符编码尽量的短。UTF-8的编码规则很简单，如下：1) 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的Unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。2) 对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的Unicode码。下表总结了编码规则，字母x表示可用编码的位。 可见，ASCII字符（\u0000～\u007F）部分完全使用一个字节，避免了存储空间的浪费，而且UTF-8可以不再需要BOM字节。另外，从上表中可以看出，单字节编码的第一字节为00-7F，双字节编码的第一字节为C2-DF，三字节编码的第一字节为E0-EF，这样只要看到第一个字节的范围就可以知道编码的字节数，可以大大简化算法（感兴趣的话可以自己实现编码、解码的算法）。例：以汉字“严”为例。已知“严”的Unicode（UCS-2）码是\u4E25（0100_1110_0010_0101），根据上表，可以发现\u4E25处在第三行的范围内（0000 0800 ~ 0000 FFFF），因此“严”的UTF-8编码需要3个字节，即格式是“1110xxxx 10xxxxxx10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，“严”的UTF-8编码是“111001001011100010100101”，转换成十六进制就是E4 B8 A5。可以看到“严”的Unicode码是\u4E25，而UTF-8编码是E4 B8 A5，两者是不一样的。它们之间的转换可以通过程序或一些编辑器实现。 5.3 大端、小端与字节序标记UTF-8以单字节为编码单元，没有字节序的问题。UTF-16以2个字节为编码单元，在解释一个UTF-16文本前，首先要弄清楚编码单元的字节序。例如，当我们收到6A7C时，它到底代表\u6A7C还是\u7C6A？仍以汉字“严”为例，Unicode（UCS-2）码是\u4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。因此，第一个字节在前，就是“大头/大端方式”（Big endian），第二个字节在前就是“小头/小端方式”（Little endian）。那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？Unicode编码规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做“零宽度非换行空格”（Zero Width No-Break Space），它的编码是FEFF。其FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中，UCS规范建议我们在传输字节流前，先传输字符”Zero Width No-Break Space”，这正好是2个字节，而且FF比FE大1。如果一个文本文件的头2个字节是FE FF，就表示该文件采用大头方式；如果头2个字节是FF FE，就表示该文件采用小头方式。字符”Zero Width No-Break Space”又被称作BOM（Byte Order Mark，字节序标记）。 UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符”Zero Width No-BreakSpace”的UTF-8编码是EF BB BF，所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。Windows就是使用BOM来标记文本文件的编码方式的，但实际上并不建议UTF-8格式的文件使用BOM。 6 、各种环境下的编码简单介绍完字符编码相关知识后，我们需要理解不同环境下的字符编码问题，这对程序猿/媛们来说更为重要。谈及具体环境下的编码，我们实际上有以下四个层次：1) 操作系统默认编码方式。这是操作系统的内部属性，比如大多Linux系统、Mac OS默认UTF-8编码，中文版Windows系统默认GBK编码2) 终端编码方式。终端包括cmd、shell、terminal等，在与终端交互时，字符是要在终端显示的，这必然涉及到终端采用的编码方式，事实上有不少bug是在这个层面产生的。对于单机系统而言，终端编码与操作系统编码一般是一致的，但在远程登录时，可能会遇到一些问题。3) 文本文件的编码方式。这是我们接触最多的概念，即一个文本文件（如源代码文件）是以什么编码格式保存的。大多数编辑器可以显示文本的编码格式，以及更改编码方式重新存储。以下图中的Notepad++编辑器为例，在格式选项卡中显示了可以进行编码转换的选项。4) 程序中的字符、字符串变量的编码方式。这与具体的编程语言相关，涉及到程序运行时变量在内存中的状态。Python典型的encode/decode就是这个鬼。 如图 Notepad++中的编码选项以Java和Python编程语言为例。Java和Python3里，字符均采用Unicode编码（Java.lang.String 采用 UTF-16 编码方式存储所有字符），因此可以很好地支持中文。但是，Python2中Unicode不是字符默认编码格式（Python从2.2才开始支持Unicode），因此需要进行编码的转换。函数decode( char_set )可以实现其它编码到Unicode的转换，函数encode( char_set )可以实现Unicode到其它编码方式的转换，这里所讲的Unicode String是指UCS-2或者UCS-4 编码的Code Points。比如， (“你好”).decode(“GB2312”) 将得到 u’\u4f60\u597d’，即“你”和“好”的 Unicode 码分别是0x4f60 和 0x597d，再用(u’\u4f60\u597d’).encode(“UTF-8”) 就可以得到“你好”的UTF-8编码结果：’\xe4\xbd\xa0\xe5\xa5\xbd’。【请注意，这些运行结果跟具体的操作平台有关，读者可以思考为什么，相关解答可以参考知乎(Python2.7 中文字符编码，使用Unicode时，选择什么编码格式？ - Kenneth的回答)对此的解释，本小节也是受到该回答的启发整理而成】 图 3 Unicode decode/encodein Python （摘自Nature Language Processing with Python, 2 edition）实际上，Python 3和2很大区别就是Python本身改为默认用Unicode编码。字符串不再区分”abc”和u”abc”，字符串”abc”默认就是Unicode，不再代表本地编码，由于有这种内部编码，与C#和Java类似，没有必要在语言环境内做类似设置编码，也因此Python 3的代码和包管理上打破了和2.x的兼容。再次提醒：只有字符到字节或者字节到字符的转换才存在编码转码的概念。 7、 编码总结总结一下上述内容：1、编码界最初只有ASCII码，只用了1byte中的7bit（0~127）；2、欧洲人发现128个不够了，就把1byte中没用的最高位给用上了，出现了Latin系列（ISO-8859系列）编码；3、中国人民通过对ASCII编码进行中文扩充改造，产生了GB2312编码，可以表示6000多个常用汉字；4、汉字实在太多了，还有繁体、各种字符呀，于是加以扩展，有了GBK；5、GBK还不够，少数民族的字还木有呀，于是GBK又扩展为GB18030；6、每个国家、语言都有自己的编码，彼此无法交流，迫切需要大一统局面的出现；7、Unicode诞生，可以容纳全世界的任何文字。Unicode分为UCS-2和UCS-4，分别是2字节和4字节，实际2字节就够用了；8、为了Unicode能实际应用（存储、传输），制定了Unicode的编码方式，即UTF，有UTF-8、UTF-16、UTF-32，其中UTF-8应用广泛；9、UTF-16、UTF-32均是多字节传输，存在字节顺序的问题，于是有了大头还是小头的概念，为了解决这个问题，引入了BOM。UTF-8是单字节传输，不存在这个问题，也就不需要BOM，但可以有，仅用来表明编码格式；10、要从“环境/终端/文本/程序”等不同层次去理解编码，并尝试解决遇到的问题； 8 、最后的叨叨念各种编码方式的不一致，环境平台的不一致，会导致在编程中遇到各种头疼的bug。如果对这些相关的概念有一定的了解，至少在解决问题时会从容很多。为了最大程度上减少可能产生的问题，可以在平时多注意一些细节，一方面方便个人开发，另一方面减少对二次开发用户的干扰。比如：1)可以的话，文本尽量以UTF-8（无BOM）方式存储。对于Windows用户，强烈建议弃用默认的文本编辑器，采用一款更专业的编辑器，并将默认编码格式设置为UTF8（无BOM）。2)跨平台开发时，如果需要在terminal输出，注意terminal的编码方式，有时采用重定向到文件会是一个更加通用的选择。3)对于Python用户，如果不是相关依赖项只有py2版本，强烈建议采用py3开发，会减少很多中文相关的问题。4)路径、文件、变量等按照规范命名。比如，听说Java支持用中文命名变量了，因此可能会出现这样的代码，String 哈哈 = “2333333”; 为了减少后续可能遇到的问题，奉劝还是不要这样，不做死就不会死。]]></content>
  </entry>
  <entry>
    <title><![CDATA[problem]]></title>
    <url>%2F2018%2F03%2F14%2Fproblem%2F</url>
    <content type="text"><![CDATA[Python 使用requests时的编码问题 当你收到一个响应时，Requests会猜测响应的编码方式，用于在你调用 Response.text 方法时 对响应进行解码。Requests首先在HTTP头部检测是否存在指定的编码方式，如果不存在，则会使用 charade 来尝试猜测编码方式。 只有当HTTP头部不存在明确指定的字符集，并且 Content-Type 头部字段包含 text 值之时， Requests才不去猜测编码方式。 在这种情况下， RFC 2616 指定默认字符集 必须是 ISO-8859-1 。Requests遵从这一规范。如果你需要一种不同的编码方式，你可以手动设置 Response.encoding 属性，或使用原始的 Response.content 。 12345r = requests.get(url)print(r.encoding) #查看默认编码原则# ISO-8859-1r.encoding = 'gbk' #设置默认编码位gbk pip Errorpip UnicoDecodeError123456789101112C:&gt;pip install tesserocrCollectiong tessorocr Using cached tesserocr-2.2.2 tar.gzException:Traceback (most recent call last): File "E:\Anaconda\setup\lib\site-packages\pip\compat\__init__.py", line 73, in console_to_str return s.decode(sys.__stdout__.encoding)UnicodeDecodeError: 'utf-8' codec can't decode byte 0xd5 in position 70: invalid continuation byte..................UnicodeDecodeError: 'utf-8' codec can't decode byte 0xd5 in position 70: invalid continuation byte 解决方法 将第75行return s.decode(‘utf-8’)改为return s.decode(‘cp936’) #编码你到底是为咋样？？？？cp936 1234567891011121314C:\Users\m1527&gt;pip install tesserocrCollecting tesserocr Using cached tesserocr-2.2.2.tar.gzBuilding wheels for collected packages: tesserocr Running setup.py bdist_wheel for tesserocr ... error Complete output from command E:\Anaconda\setup\python.exe -u -c "import setuptools, tokenize;__file__='C:\\Users\\m1527\\AppData\\Local\\Temp\\pip-build-wtue_u6g\\tesserocr\\setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))" bdist_wheel -d C:\Users\m1527\AppData\Local\Temp\tmp22tx5rglpip-wheel- --python-tag cp36: Failed to extract tesseract version from executable: [WinError 2] 系统找不到指定的文件。 Supporting tesseract v3.04.00 Building with configs: &#123;'libraries': ['tesseract', 'lept'], 'cython_compile_time_env': &#123;'TESSERACT_VERSION': 197632&#125;&#125; running bdist_wheel running build running build_ext building 'tesserocr' extension error: Microsoft Visual C++ 14.0 is required. Get it with "Microsoft Visual C++ Build Tools": http://landinghub.visualstudio.com/visual-cpp-build-tools 注意看 error: Microsoft Visual C++ 14.0 is required. 意思缺少Visual C++呗下载吧！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[爬虫之妹子图]]></title>
    <url>%2F2018%2F03%2F13%2F%E7%88%AC%E8%99%AB%E4%B9%8B%E5%A6%B9%E5%AD%90%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[抓取妹子图1、安装所需模块 2、开始撸代码 爬虫入口–存储数据–获取资料的URL地址–创建文件夹保存图片]]></content>
      <tags>
        <tag>python Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[annconda]]></title>
    <url>%2F2018%2F03%2F12%2Fanaconda%2F</url>
    <content type="text"><![CDATA[一直有听说Anaconda,作为一个集成多个包的python发行版，一直名声在外呀！ 今天就来见识一下。 Windows下安装Anaconda及多版本管理1、 清华镜像下载对应版本 2、安装。ps:命令行输入python依然显示不出Anaconda，估计是已经安装了pyhton3.6. 3、解决问题——安装Anaconda之前已经安装python3.怎么解决 不好使呀！删除python3.6重装Anaconda得了。 Anaconda多环境多版本配置 Anaconda安装虚拟环境到指定路径 12345678910111213141516171819&gt;conda --version #查看conda版本&gt;conda info --envs #查看已有python环境&gt;conda create --name python27 python=2.7 #自动部署最新版python2.7环境&gt;python --version #查看当前使用python版本&gt;activate python27 #切换当前python版本到python2.7&gt;deactivate #从当前目录切换到根目录&gt;conda remove --name python27 --all #删除python27环境&gt;conda install -n *** 123 #将包123安装到***环境中。否则默认安装到当前环境&gt; conda create --prefix=D:\python\fsk python=3.6 #自动部署fsk环境到D:\python中&gt; activate D:\python\fsk #激活指定路径下的虚拟环境#anaconda下使用virtualenv创建python虚拟环境&gt; pip install virtualenv #安装virtualenv包&gt; virtualenv --version #查看是否安装virtualenv包&gt; virtualenv venv #在当前路径下创建一个名字是venv的虚拟环境。&gt; activate #激活当前路径下的虚拟环境(env) F:\git&gt; python hello.py #在激活环境的条件下运行hello.py程序(env) F:\git&gt; deactivate #deactivate 退出虚拟环境，返回全局python解释器 Anaconda和Pycharm安装和配置教程 Ubuntu下安装Anaconda]]></content>
  </entry>
  <entry>
    <title><![CDATA[algorithm]]></title>
    <url>%2F2018%2F03%2F11%2Falgorithm%2F</url>
    <content type="text"><![CDATA[初识算法算法就是你解决问题的方法。 时间复杂度与空间复杂度 关于时间复杂度的详解 常见的时间复杂度有： 常数阶O(1)&lt;对数阶O(log2n)&lt;线性阶O(n),&lt;线性对数阶O(nlog2n) &lt;平方阶O(n^2)&lt;方阶O(n3)&lt;k次方阶O(n^k) &lt;指数阶O(2^n)&lt;O(n!)&lt;O(n^n) 时间复杂度计算步骤： 1、找到执行次数最多的语句 2、计算语句执行次数的数量级 3、用打 O来表示结果]]></content>
  </entry>
  <entry>
    <title><![CDATA[asyncio]]></title>
    <url>%2F2018%2F03%2F11%2Fasyncio%2F</url>
    <content type="text"><![CDATA[为了解决CPU高速执行能力和IO设备的龟速严重不匹配，一个IO操作就阻塞了当前线程问题。通过多线程和多进程实现并发；另一种解决IO问题的方法是异步IO。 同步IO模型的代码是无法实现异步IO模型的。 异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程： 消息模型是如何解决同步IO必须等待IO操作这一问题的呢？当遇到IO操作时，代码只负责发出IO请求，不等待IO结果，然后直接结束本轮消息处理，进入下一轮消息处理过程。当IO操作完成后，将收到一条“IO完成”的消息，处理该消息时就可以直接获取IO操作结果。 协程，又称微线程，纤程。英文名Coroutine。 协程的调用和子程序区别： 子程序调用总是一个入口，一次返回，调用顺序是明确的。 协程看上去也是子程序，但执行过程中，在子程序内部可中断（类似CPU中断），然后转而执行别的子程序，在适当的时候再返回来接着执行。 协程的特点在于是一个线程执行。 协程最大的优势是极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制。 Python对协程的支持是通过generator实现的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQLAlchemy]]></title>
    <url>%2F2018%2F03%2F10%2Fpython-SQLAlchemy%2F</url>
    <content type="text"><![CDATA[ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上。 创建一个class对象表示数据库的一个表，用class实例表示表中的一行数据。 Python中，最有名的ORM框架是SQLAlchemy。我们来看看SQLAlchemy的用法。 123456789101112131415161718192021222324252627282930#导入SQLAlchemy,并初始化DB session：from sqlalchemy import Column,String,create_enginefrom sqlalchemy.orm import sessionmakerfrom sqlalchemy.ext.declarative import declarative_base#创建对象基类：Base = declarative_base()#定义User对象：class User(Base): #表的名字： __tablename__ = 'user' #表的结构： id = Column(String(20),primary_key=True) name = Column(String(20)) #初始化数据库连接：engine = create_engine('mysql+pymysql://root:password@localhost:3306/test')#创建DBSession类型：DBSession = sessionmaker(bind=engine)#创建session对象：session = DBSession()#创建新User对象：new_user = User(id='5',name='bob')#添加到session:session.add(new_user)#提交即保存到数据库:session.commit()#关闭session:session.close()]]></content>
  </entry>
  <entry>
    <title><![CDATA[python SQLite]]></title>
    <url>%2F2018%2F03%2F10%2Fpython-SQLite%2F</url>
    <content type="text"><![CDATA[SQLite是一种嵌入式数据库，它的数据库就是一个文件。 操作关系数据库，首先要连接到数据库，一个数据库连接称为Connection; 连接到数据库后，需要打开游标，称之为Cursor,通过Cursor执行SQL语句，然后，获得结果。 12345678910111213141516171819202122232425262728#导入SQLite驱动import sqlite3#连接到SQlite数据库#数据库文件时test.db,如果文件不存在，会自动在当前目录创建：conn = sqlite3.connect('test1.db')#创建一个Cursor:cursor = conn.cursor()#执行一条SQL语句，创建user表：cursor.execute('create table user (id varchar(20) primary key,name varchar(20))')#执行一条SQL语句，插入一条记录：cursor.execute('insert into user (id,name) values (\'1\',\'michal\')')#通过rowcount查询插入行数：cursor.rowcount#关闭cursorcursor.close()#提交事务：conn.commit()#关闭Coonection:conn.close()#查询记录：conn = sqlite3.connect('test1.db')cursor = conn.cursor()cursor.execute('select * from user where id = ?',('1',)) #注意此处的''范围，不同于createvalues = cursor.fetchall()print(values)cursor.close()conn.close() sqlite3连接数据库时如果文件已经存在汇报错，需删除当前目录下xx.db文件，然后重新执行。]]></content>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python下TCP编程]]></title>
    <url>%2F2018%2F03%2F10%2FTCP-IP%2F</url>
    <content type="text"><![CDATA[网络编程网络编程就是如何在程序中实现两台计算机的通信.也即两个进程之间的通信。 TCP/IP简介因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP/IP协议。 IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。 TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。 什么是TCP/IP协议 TCP编程Socket(套接字)是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 1234567891011121314151617181920212223242526#导入socket库：import socket#创建一个socket对象:s = socket.socket(socket.AF_INET,socket.SOCK_STREAM) #AF_INET指IPV4协议，SOCK_STREAM指面向流的TCP协议#建立连接:s.connect(('www.sina.com.cn',80))#发送数据：s.send(b'GET / HTTP/1.1\r\nHost:www.sina.com.cn\r\nConnection:close\r\n\r\n')#接受数据：buffer = []while True: d = s.recv(1024) if d: buffer.append(d) else: breakdata = b''.join(buffer)#关闭连接：s.close()#数据处理header, html = data.split(b'\r\n\r\n',1)print(header.decode('utf-8'))#把接收的数据写入文件：with open('sina.html','wb') as f: f.write(html) 知识点补充URL统一资源定位。我们可以这样认为：一个URL地址，它用于描述一个网络上的资源。 HTTP中GET,POST,PUT,DELETE就对应这个资源的查，改，增，删4个操作。 响应代码释义： ​ 200 表示成功。 ​ 3xx 表示重定向。 ​ 4xx 表示客户端发送的请求有错误。 ​ 5xx 表示服务端处理时发生错误。]]></content>
      <tags>
        <tag>python network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汉尼拔]]></title>
    <url>%2F2018%2F02%2F28%2F%E6%B1%89%E5%B0%BC%E6%8B%94%2F</url>
    <content type="text"><![CDATA[汉尼拔·莱克特^注释是欧洲贵族，他的家庭毁于一场战乱，然而，贵族的血脉不是那么容易灭绝的，所以身边的父母家人全部去世以后，汉尼拔可以逃跑到法国的姨妈家，接受最好的教育。要知道，在那个年代，医学可是非常吃香的，供一个小孩无忧无虑读书到毕业，说明这个家族还是可以的。 所以一开始汉尼拔就不是什么屌丝逆袭，这样一个像浮士德一样的人物，是出身名门的。只不过，他的聪明敏锐以及从小的经历，让他明白了人性本恶的道理，使他在未来成为了一个玩世不恭的，挑战现行社会制度和人类社会约定俗成的法则的“犯罪分子”，用自己的智商和犯罪手段，来讽刺这个社会。 汉尼拔学的是医学和心理学，为什么不安排他学核物理，最后成为钢铁侠？学化学，最后成为绿巨人？学生物学，最后成为蜘蛛侠？为什么偏偏是医学加心理学？ 是的，作者要他来全面修理西方文明中那些罪恶的身心。 《汉尼拔崛起》讲了这么样一个故事，一群中欧的匪兵，在天下大乱的时候，做了外敌， 纳粹军队的走狗，帮助他们屠杀同胞，当苏军取得压倒性胜利的时候，他们又趁火打劫叛变粹， 成了抵抗外敌的英雄，在大雪封山的时候，他们吃了汉尼拔的妹妹，在战争结束后，他们又摇身一变，成为了英雄，士绅，官员，成为了当时那个社会的中流砥柱。 在这里，妹妹是一个象征，是汉尼拔儿时心中最美好的东西，最希望呵护和捍卫的东西，这个象征就被人当着汉尼拔的面扒光了煮来吃了，关键是，为了生存，汉尼拔自己也吃了…..然后这个BUG将伴随他一生。 当今社会谁又没有类似的体验呢? 这个妹妹可以是上天赐予你的土地，还有这上面的物产。有一天，一群匪徒杀进你的家，拿枪抵着你的头，告诉你，这一切都要由他们来分配，于是，他们吃了大头，你吃了一点残羹，勉强维持生存。 然而谁计较过他们？谁惩罚过他们？没有人。这个世界就是个成王败寇的世界。你活下来了，你有钱，你赢了，那么你说了算。你曾经为了活下来，为了胜利做的一切，没有人计较，没有人可以计较。这就是现实。 然而，拔叔计较，拔叔出来了，把他们都煮来吃了，所以这样的情节很反动，说得太直接、太现实、太血淋淋了。 拔叔本来是和妹妹在自己花园里捞鱼，想无忧无虑地安安静静地长大的美男子，是一场什么样的战争，毁灭了他的生活？是一场资本主义狗咬狗的争夺霸权的战争，尤其又是在战争末期，是苏联和英美联军之间打残兵抢地盘如吃豆一般展开竞赛的时候，在这场人类历史上最大的浩劫的尾声里，汉尼拔失去了自己的父母，和自己最心爱的妹妹。所以，对于它来讲，这个世界上那些强权所伸张的正义，就是它们作威作福，祸乱人间的遮羞布而已。 接下来，拔叔流蹿到了美国，没想到美国也是一样的。 我们来到《红龙》，在这里，汉尼拔是美国FBI，警察的座上宾， 要不是因为小茶杯天赋秉异，可能没有人能发现他竟然是那么顽皮。请注意，在原著中，小茶杯是凭借敏锐直觉偶然发现汉尼拔的蛛丝马迹的，他去汉尼拔家，是为了获得汉尼拔的帮助，来破获另外一个案件。这讽刺什么，讽刺美帝所谓的法制、科技、侦查技术的平均水平烂得掉渣，只唬得住小屁孩，对于精英和杂碎这两个极端根本就形同虚设。 说明我们生存的世界漏洞百出，居然要靠超级英雄和天才儿童来维护，说明那些西装革履，循规蹈矩的官僚们愚蠢之极，形同虚设。 接下来来到《沉默的羔羊》。资本主义社会造就了野牛比尔这样的变态狂，杀了那么多人，做了那么多恶，这个社会在乎吗？不在乎。那些变成了一张张人皮的鲜活生命，只不过就是FBI失踪人口调查文件上的一个数字！直到议员的女儿被绑架了，警察才开始打鸡血。这是什么？这是属于权贵，属于统治阶级的社会。法制？平等？正义？算了吧，当汉尼拔在调侃议员咪咪的时候，简直就是对这个社会的“正义的游戏规则”最大的讽刺——一个议员，为了救自己的女儿，求助于罪犯，最后玩脱了，罪犯跑了，这就是剧情。为什么议员就可以坏规矩呢？如果是隔壁老王的女儿被水牛比尔绑架了，有没有人管呢？如果不是出生平民的克拉丽丝探员冒险坚持，最后又救不救得出人质呢？ 最精彩的当属《人魔》，简直就是画龙点睛，小说的结局是，当克拉丽丝发现她所为之奋斗终身的体制本质上就是邪恶的的时候，在汉尼拔的点化和帮助下，把这个体制的代言人克伦德勒的大脑吃掉了，然后神仙眷侣携手私奔——多么地解恨！ 电影就温和多了，为了审核通过，还是保留了克拉丽丝正义的形象，一直在反抗，导致汉尼拔英雄断臂。这个改编其实非常之失败，比较原著的思想精髓真是大为失色。但是没有办法，因为在新闻界混了几十年的狡猾的托马斯·哈里斯老爷子这一下真的捅到了这个社会的最见不得人的菊花，衣冠禽兽们道貌岸然地站出来告诉他：“是这个理，但是你娃不要说这么透好不好？” 即使这样，作品要表达的核心思想是没变的——在某些时期，某些社会结构下，上流的人最下流，下流的人不择手段上位成功就成为了统治阶级，而统治阶级的利益大于一切，他们是一切罪恶的始作俑者，都该受到审判而没有受到审判。 最后只有YY，只有让一个”神“来吃掉你们这些猪腰子牛胰脏一样的烂杂碎。梅森、克伦德勒这些杂碎操纵着这个国家的司法、刑侦、舆论，甚至正义的价值观，什么克劳福德、克拉丽丝这些稍微有点正义感的公务员，只不过是背黑锅的。他们很无力。小说中鱼市后一章停职克拉丽丝的时候，专门描述了克劳福德老头子，他本来要保护自己的部下，结果被支到图书馆去喝茶，最后竟然在那里心脏病发作。 克拉丽丝选择的是在体制内，用自己的努力来改变这个体制，最后的结果是，作为一个平民，他只不过是一个棋子而已，最后竟然连守住自己名誉和尊的基本底线都无法做到。汉尼拔是在体制外的，用自己的暴力来改变这个体制，最后的结果是理想化的，因为在现实里，这样的人最终会分化为两种——革命者和犯罪分子，王和寇。作者让汉尼拔成为了隐藏在市井之中的革命者，这简直就是浪漫主义，因为在当今社会，互联网时代，敢这么嚣张的人，是不存在的。 更加升华一层，汉尼拔更是代表了一个阶级——知识分子阶级，甚至可以代替一类人——犹太人的处境。越是落后的社会越是被流氓统治的，他们通过家族世袭或者暴力巧取豪夺了政权，但是维护一个政权，那些只会暴力的纨绔子弟是搞不定的，他们需要在有法理的情况下努力薅羊毛，一般情况下都是少精英剥削多数傻x。 统治阶级薅穷苦大众的羊毛，如果薅厉害了，穷苦大众就会揭竿而起，推翻统治阶级，如果不薅，庞大的国家机器又难以运行，因此为了合理化自己的统治与剥削，最需要知识分子来贡献薅羊毛的方法和迷惑群羊的说辞。知识分子是不具备土地、资本、手艺、甚至劳动力的一个阶层，他们有的生产要素是知识，他们必须依靠自己的知识去寻租，《汉尼拔》电视剧最突出的就是，拥有大量资源，代表统治阶层的探员拜访幼年时就失去了土地和资本，仅仅拥有知识和手艺的汉尼拔，向他请教，取得经验和灵感。 拥有知识的阶层最看得清楚这个社会得问题和本质，说出口的大多都是令人折服的真理，他们是最厉害的一个阶层，也是防御力最低的一个阶层，相当于大法师只能放魔法，砍人就不行了。因此无论是哪个国家，知识分子对于统治阶层来说，是最重要的谋士，也是最危险，随时需要被提防的，古有秦始皇焚书坑儒，今有纳粹迫害犹太科学家。从一定角度上来说，知识分子就像犹太人一样，一群地痞流氓需要用你的时候，就薅羊毛，不需要的时候，就送集中营。 汉尼拔作为一个高级知识分子，他完全是反传统反结构的，他没有成为一只小绵羊任人宰割，而是成为了狡猾的老狐狸，用自己的知识和经验在改造统治阶级。这一点，也很像对今天犹太人的隐喻，如今美国社会前200的精英，大多数是那些曾经受到各种利用、迫害、排挤、流离失所，四处流浪的犹太人。 最后作品告诉我们什么呢？ 我们生活在一个罪恶的，成王败寇的世界。那些高高在上的人，他们因为血脉的缘故高高在上，他们以及他们的家族制定了法律，制定了规矩来约束芸芸众生，自己却在大庄园里玩papa，割脸，在办公室里调戏下属。那些理想化的人，被这个体制物化的人，希望成为忠犬，迫切希望改变自己的阶级，或者得到体制的接纳和认可，然而，自己只不过是随时可以牺牲掉的工具而已。那些和体制作对的人，分为有意识的和无意识的，水牛比尔，红龙都是无意识的，自己玩得HIGH的小朋友，都是因为触及了体制（一个是得罪了议员，一个是得罪了FBI)，然后很快就被搞掉了。而汉尼拔这种了解体制，智商又超越凡人，并且有意识的坏蛋，体制拿他是一点办法都没有，有时候，还一起同流合污（喝茶吃饭）。 这本书的前3/4是反人类的，是在教人用暴力反抗强权，用血来浇灌自由，这本书是在教人做世界上最危险的事——GM，推翻一个旧的世界，创造一个新的世界。然而，这本书之所以能够被推广，第一，因为它诞生于相对民主的资本主义国家，诞生在美帝，可以作为一种对现行制度漏洞和社会问题的批判和讽刺而存在。第二，作者没有将反动的思想推而广之，拔叔和克拉丽丝最后解放的是自己，而不是这个社会，他们最后隐了，两个人跑到美国法律干涉不到的地方去过神仙日子了，而没有傻不拉几的去白宫讨个公道正义什么的，因为他们知道，没有公道和正义，他们的智商和能力再高，也只能勉强碰运气搞定个别人，而面对国家机器，一定是分分钟被消灭。第三，正义最终战胜了邪恶，这里给大家一个彩蛋，你们可能觉得在汉尼拔系列里，克拉丽丝就是一个花瓶，拔叔才是最牛逼的，吃遍天下。 你们错了，说了多少次了，要看原著! 最后一部分，克拉丽丝像妈妈一样把拔叔治了，拔叔吸了奶，就再也不瞎折腾了—— “……她的眼睛和耳坠在火光里闪耀。火光边有一声叹息，炉火的温暖透进了她的晚礼服。史达琳心里闪过一个瞬息即逝的回忆——很久以前莱克特博士问过马丁参议员，她是否给她的女儿哺乳。一个闪着珠宝光芒的动作在史达琳不自然的平静里翻腾：瞬息之间她心灵的窗户开启了好几扇，让她远远望出了自己的经历以外。 她说：“汉尼拔·莱克特，你妈妈喂你奶吗？” “喂的。” “你有过非把Rx房放弃给米沙不可的感觉吗？你曾经觉得非放弃给她不可吗？” 好一会儿。“我想不起来，克拉丽丝。如果我放弃了的话，也是高高兴兴地放弃了的。”克拉丽丝·史达琳将手拢成杯状伸进她长袍领口的深处，把Rx房解放了出来。“这个Rx房你就不用放弃了。”她说。她一直望着他的眼睛，用扣扳机的指头从唇边拿开了温暖的依甘堡酒。一滴香而浓的酒挂到她乳头上，像一枚金色的耳坠，在随着她的呼吸颤动。 他飞速离开椅子向她跑去，在她的椅前一条腿跪下，向那珊瑚红与奶油白俯过身去；他那帅气黑亮的头映着火光。”引自《汉尼拔》第六部 长勺 第一百零一章作者：托马斯·哈里斯]]></content>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ububtu14.04下搭建以太坊私有链开发环境]]></title>
    <url>%2F2018%2F02%2F27%2F%E5%9F%BA%E4%BA%8E%E8%8E%B1%E8%8C%A8%E7%8B%97%E7%9A%84dapp%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[1、概念解析dapp-decentralized App CryptoKitties 莱茨狗 ： 8个特征2个属性6个等级 点我 以太坊：区块链系统，增加了智能合约，不同于比特币纯货币功能。以太币：以太坊区块链系统上的所有操作都要消耗以太币。智能合约：Smart Contrat,用程序代码(Solidity)写的合约，使得合约双方不需要信任彼此也可以进行交易。 Solidity :编写智能合约的语言，是以太坊开发者专门为编写智能合约设计的一种编程语言。 Truffle 基于以太坊的Solidity语言的一套开发框架。 Remix :是一个基于solidity语言的在线智能合约开发IDE，它提供从编译，调试到部署的全流程工具，功能非常强大。 2、安装Truffle安装Truffle依赖Nodejs1234qp@qpxxx:~$ curl -sl http://deb.nodesource.com/setup_9.x | sudo -E bash - #指定版本源qp@qpxxx:~$ sudo install -y nodejsqp@qpxxx:~$ sudo apt-get install npmqp@qpxxx:~$ sudo npm config set regisitry http://registry.npm.taobao.org #配置npm源为国内源 安装Truffleqp@qpxxx:~$ sudo npm install -g truffle 3、创建工程123qp@qpxxx:~$ mkdir mycoinqp@qpxxx:~$ cd mycoinqp@qpxxx:~$ truffle unbox metacoin 4、安装以太坊客户端 下载Truffle 这些可执行文件的后缀都比较奇葩，参见下面的对应关系： ● Windows: Ganache-*.appx ● Mac: Ganache-*.dmg ● Linux: Ganache-*.AppImage123qp@qpxxx:~$ wget https://github.com/trufflesuite/ganache/releases/download/v1.0.1/ganache-1.0.1-x86_64.AppImage //下载ganacheqp@qpxxx:~$ chmod +x ganache-1.0.1-x86_64.AppImage //修改权限qp@qpxxx:~$ sudo ./ganache-1.0.1-x86_64.AppImage //启动ganache 5、修改配置文件、编译和部署合约修改mycoin文件下的truffle.js配置文件如下。123456789module.exports = &#123; networks: &#123; development: &#123; host: 'localhost', port: '7545', network_id: '*' // Match any network id &#125; &#125; &#125;; 编译及部署123qp@qpxxx:~$ cd mycoin #进入工程目录qp@qpxxx:~/mycoin$ truffle complete #编译合约qp@qpxxx:~/mycoin$ truffle migrate #部署合约,需提前启动Ganache 6、测试合约1qp@qpxxx:~/mycoin$ truffle test 7、参考Trurrle与Ganache主要参考以太坊Dapp开发入门1：开发环境的搭建Dapp开发教程-hello world一步步教你开发、部署第一个去中心化区块链应用-宠物商店 8、踩坑重置了Ganache上部署合约后truffle migrate报错可执行truffle migrate –reset重新部署 9、思考我们个人，一定不能以旧的思维方式来对待新事物，而是要以全新的思维方式来理解，并且是认真的对待。因为新的时代下，消灭你，与你无关。]]></content>
  </entry>
  <entry>
    <title><![CDATA[影翼杀手观后感]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%BD%B1%E7%BF%BC%E6%9D%80%E6%89%8B%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[银翼杀手作为一部1982年上映的科幻片，影片以2019年的洛杉矶作为故事背景。现在(2018年)看来依然很超前，我们在2019年还是普及不了片中的高科技(语音操作，空中飞车，生物科技)。这部片子在当时那个科技开始普及的时代已经超前的那个时代太多，民众的科技素养欠缺的阶段意识难以接受。在计算机科技时代我们经历的太多的变迁。于我以前看电影只是看的热闹，现在看电影更多的看到是电影的内涵及给人的启示与思考。一本好多书籍、好多科技电影、好多音乐真的会改变一个人的未来、思维的深度、人生成就。只是我们以前太年轻，缺少正确的引导。很多次改变的机会都于我们擦肩而过，自己却不自知，缺少引导不可怕，可怕的是引向了歧路。经历了饥饿到温饱，战争到和平，落后到小康。未来一定是科技与生命的思考，必将掀起一场生物开科技的革命。我的记忆，是真实的吗？]]></content>
      <tags>
        <tag>movie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker制作hexo镜像]]></title>
    <url>%2F2018%2F02%2F25%2Fdocker%E5%88%B6%E4%BD%9Chexo%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[学习docker已经有几日了，看来那末多教程，总想实践一把，毕竟实践才是检验真理的唯一标准嘛。 参考了下面的一些操作。使用hexo+github搭建个人博客使用Hexo+Github+Ubuntu搭建博客Ubuntu平台下通过Hexo在Github上搭建个人博客使用dock制作hexo镜像使用docker和hexo搭建DevOps个人静态博客 思路和window下是一样的。1、安装git,nodejs.2、安装hexo.(在这里遇到了两个坑，一个时执行npm install hexo时提示没有npm;第二个是执行hexo init提示/usr/bin/env: ‘node’: No such file or directory可参考软链接) 实际操作过程1、虚拟机下安装docker2、下载ubuntu 14.04镜像执行docker run -it ubunut:14.04 /bin/bash apf-get update 后docker commit -m=”update apt-get” -a=”qinp” 容器id ubuntu14.04/hexo：版本号3、docker run 新镜像ubuntu14.04/hexo,安装git,nodejs,hexo.]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker]]></title>
    <url>%2F2018%2F02%2F24%2Fdocker%2F</url>
    <content type="text"><![CDATA[在学习linux的过程中发现了一个好的网站菜鸟教程。初入菜鸟教程结构清晰明了，可以让人对一个新的知识点快速建立框架认知。同时还可以作为平常工作的知识点查阅手册。在逗留的过程中发现了好多新的词汇，不免要了解了解。其中的docker就又为我开起来一个新的知识世界。ddocker一个go语言开发的开源的应用容器引擎，采用沙盒机制。简单点说docker就是能够将应用软件及环境部署在其容器内部生成新的镜像，实现在安装docker的环境中快速部署安装. Docker安装1、Ubuntu下docker下载安装参考教程中的wget -qO- https://get.docker.com/| sh并不能成功安装docker,查找了好多资料后，最终采用apt-get install docker.io才算完成了docker的安装在终端运行执行docker后出现了一系列docker操作参数表明docker安装成功。划重点了如果想今后要以非root用户直接运行docker时，需要执行sudo usermod -aG docker 用户名，将用户添加到docker用户组中。重启系统方可有效。 2、win10下安装下载DockerToolbox安装即可。可参考win10安装Docker (Docker for Windows目前只支持专业版坑呀！！！！) win10下cmd下使用docker可参考window下docker安装及配置镜像仓库12C:\User\m1\&gt; docker-machine ssh #cmd下进入dockerdocker@default:$ Docker使用docker使用流程分为镜像(可下载也可自己构建镜像)和容器。 docker构造镜像构造镜像创建新目录进入目录创建Dockfile文件编写Dockfile。Dockerfile由一系列指令(必须为大写字母)和参数组成每条指令都会创建一个新的镜像层并对镜像进行提交。在Dockerfile文件中执行docker build docker login 镜url #登陆镜像源 docker search # 查找镜像 docker pull #下载镜像 docker rmi #删除images docker ps #查看运行容器docker ps -a #查看所有容器docker exec -it d27bd3008ad9 /bin/bash #进入容器docker stop $(docker ps -q) #停用全部运行终中的容器docker rm $(docker ps -aq) #删除全部容器docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq) #实现停用并删除容器docker attach 名字 #进入容器exit后退出后台运行docker exec -it 容器名 /bin/sh #进入容器后exit不会退出后台 docker save -o xxx.tar 镜像名 #选择打包镜像，执行打包命令docker load -i xxx.tar #导入压缩镜像包 docker save 镜像ID &gt; xxx.tar #打包镜像docker load &lt; xxx.tar #加载镜像]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transplant]]></title>
    <url>%2F2018%2F02%2F09%2Ftransplant%2F</url>
    <content type="text"><![CDATA[今天笔记本终于到了,终于可以摆脱老笔记本的开机三分钟了。以前在搭建hexo+github博客时就思考过”如果电脑重装系统或者换电脑了怎么接着写博客”。这不机会折腾的机会就来了，开启搜索之路。在经过漫长的新机装机之路。也是有许多感触的。win10系统较于win7变化还是比较大的，基本操作做了一些改变，添加了Cortana,添加了商店(应该有很多变化吧，滑稽脸目前我只感觉到这些变化)。以前用win7真的只是办公，世界已经在发生翻天覆地的变化，自己却不知，这才是最可怕的吧！混沌前行，突然间就发现世界变了，其实不是世界变了，只是自己在舒适区待久了。要不断尝试新事物，哪怕别人win10目前兼容性还不好，win7办公足矣，但是人生不是只为工作，如果只有成长，没有进步那人生就是在原地踏步。 不断的百度，论坛各种资源的翻阅终于理清了迁移的思路。1、其实和初次搭建博客差不多，只是将以前的score、_config.yml、themes文件替换掉新环境博客目录下的同名问价就行。2、方法1会将GitHub上的提交重新覆盖，会丢失以前的记录。另一种通过分支的思想操作。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个想法]]></title>
    <url>%2F2018%2F02%2F08%2Fyigexiangfan%2F</url>
    <content type="text"><![CDATA[现在的人们生活压力大，尤其是90后一代的，现在人们对动物的依赖越来越大。也许只有自己的狗子和主子才不会嫌弃自己，才是自己的真爱吧！做一个动物语音分享视屏看来还是有需求的，需求是源泉，简单直接才是王道。配合动物’语言识别’，兽语过八级。我看行。]]></content>
      <tags>
        <tag>Light and light</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2018%2F02%2F08%2Fubuntu%2F</url>
    <content type="text"><![CDATA[类Unix系统Linux系统中一切都是文件文件管理系统linux系统启动过程内核的引导运行init系统初始化建立终端用户登录系统 后台 终端 会话 apt-get，是一条linux命令，适用于deb包管理式的操作系统，主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。 VMwarectrl+g进入虚拟机ctrl+alt退出虚拟机VMware 12安装Ubuntu server 16.04和VMware ToolsVMware Tools ubuntu server 安装使用UltraISO制作ubuntu安装u盘启动盘图文教程 ubuntu使用1、CTRL+ALT+T2、dash主页搜索终端 ubuntu有以下方式切换到root身份。1、sudo+命令，输入当前用户密码后以root权限执行命令，有时间限制且仅限当前命令。 2、sudo -i，输入当前用户密码后以root权限登录shell，无时间限制。使用exit或logout退出。 3、su，输入root账户的密码后切换到root身份，无时间限制。su 用户名切换回其它用户。 4、sudo su，效果同su，只是不需要root的密码，而需要当前用户的密码 Ubuntu下挂载及卸载U盘1、插入U盘前运行 cat /proc/partitions,查看当前有那些分区 2、插入u盘运行cat /proc/partitions 查看新增了那些分区（通常为sda、sdb） 3、fdisk -l /dev/sdb #查看U盘格式 3、执行挂载命令sudo mount -t msdos /dev/sdb /mnt/usb #/mnt/usb当前存在 fat16 mount -t msdos /dev/sdb1 /mnt/usb fat32 mount -t vfat /dev/sdb1 /mnt/usb ext2 mount -t ext2 /dev/sda1 /mnt/usb 4、cd /mnt/usb #即可使用u盘 5、使用完毕执行sudo umount /mnt/usb vimUbuntu的vim使用在命令行窗口中输入以下命令即可 启动vimvim 直接启动vimvim filename 打开vim并创建名为filename的文件显示行号：set nu 显示行号：set nonu 取消显示行号：set nu! 取消显示行号a\i\o进入编辑模式退出命令 :wq 保存并退出 ZZ 保存并退出 :q! 强制退出并忽略所有更改 :e! 放弃所有修改，并打开原来文件 常见命令delectcd filecd ~ #切换到家目录cd / #切换到根目录poweroff #立刻关机(root用户使用)shutdown -r 10 #十分钟后重启(root用户使用)rm -r 文件夹名 #删除一个不是空的文件名rm -f 文件名 #强制删除一个文件mkdir file #创建一个目录touch filename #创建一个文件linux压缩和解压命令大全linux下tar压缩解压命令详解 Ubuntu下解压.tar.xz文件 rhel7root;qprootlocaluser:12345 ln -s 源文件 目标文件 #软链接这是一个深坑。 策略 规则 多个规则合成一个链 控制类型ACCEPT：允许通过LOG:记录日志信息REJECT：拒绝通过，必要时给出提示。DROP：直接放弃 规则链依据处理数据包的位置不同而进行分类PREROUTING:在进行路由选择前处理数据包INPUT:处理入站的数据包OUTPUT:处理出站的数据包FORWARD:处理转发的数据包POSTROUTING:在进行路由选择后处理数据包 Iptables中的规则表是用于容纳规则链raw表：确定是否对该数据进行状态跟踪managle表：为数据包设置标记nat表：修改数据包中的源、目标IP地址或端口filter表：确定是否放行该数据包（过滤） iptables [-t 表名] 选项 [链名] [条件] [-j 控制类型] SNAT源地址转换技术（让多个内网用户通过一个外网地址上网）DNAT目的地址转换技术（让外网IP用户访问局域网内不同的服务器） nmtui 常见问题sudo apt-get install xx #无法定位软件包 可通过修改etc/apt/source.list文件，在其中添加国内镜像源 如： http://mirrors.163.com/ubuntu/ 此处参照其他格式补齐。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2018%2F02%2F07%2FNginx%2F</url>
    <content type="text"><![CDATA[Nginx (engine x)是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3） 代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强.因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。 代理（英语：Proxy），也称网络代理，是一种特殊的网络服务，允许一个网络终端（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击。 提供代理服务的电脑系统或其它类型的网络终端称为代理服务器（英文：Proxy Server）。一个完整的代理请求过程为：客户端首先与代理服务器创建连接，接着根据代理服务器所使用的代理协议，请求对目标服务器创建连接、或者获得目标服务器的指定资源（如：文件）。在后一种情况中，代理服务器可能对目标服务器的资源下载至本地缓存，如果客户端所要获取的资源在代理服务器的缓存之中，则代理服务器并不会向目标服务器发送请求，而是直接返回缓存了的资源。一些代理协议允许代理服务器改变客户端的原始请求、目标服务器的原始响应，以满足代理协议的需要。代理服务器的选项和设置在计算机程序中，通常包括一个“防火墙”，允许用户输入代理地址，它会遮盖他们的网络活动，可以允许绕过互联网过滤实现网络访问。 反向代理服务器架设在服务器端，通过缓冲经常被请求的页面来缓解服务器的工作量。 服务器是独立的硬件设备.有独立的内存.硬盘.带宽.用户可以根据需要安装与配置各种网站环境.以及运行各种软件.无论是性能还是安全方面都非常强大.但相对的成本也较高.主要是针对较大规模的网站来使用. 空间又叫虚拟主机.它是利用虚拟化技术在服务器硬盘上划分出来的一部分虚拟容量.共享的是服务器的IP和带宽.它只有一个FTP权限.用户通过FTP将网站数据上传到虚拟主机目录.并解析域名来实现访问.功能比较单一.它所支持的程序也是在服务器上默认配置好的.无论是性能还是安全方面都与服务器有很大的差距. VPS是虚拟服务器的意思.它是在服务器上划分出来的一部分资源搭建而成.有独立的内存.硬盘.带宽.而且有独立的IP.在功能与使用上与服务器一模一样.用户在本地通过远程操作即可.可以根据需要安装各种操作系统.可以配置各种网站运行环境.阿里云ubuntu部署hexo,并与本地同步，实现自动部署阿里云Esc建网站独享虚机一元使用2周]]></content>
      <tags>
        <tag>厚积薄发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客进阶]]></title>
    <url>%2F2018%2F02%2F06%2Fhexo%E5%8D%9A%E5%AE%A2%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[==墙裂推荐使用Typroa^注释编写博客== 不日前，完成了了blog的搭建，又花了几天更换了next主题参照官方文档完成了主题配置。总感觉每次登陆自己的博客，域名好LOW呀！这不看到了这篇文章,废话不多说开干！ 购买域名本篇以阿里云为例 首先注册阿里云账号，如果有淘宝账号的，可以直接登录。 登录以后，先进行实名认证（购买域名要用到 认证信息提交完毕后，可能需要一两天的审核时间。 认证完毕后回到首页，上方导航栏，产品-&gt;点击 万网，搜索自己想要的域名并进行购买（域名持有者选择个人，这里就用到之前的认证）。 购买完毕后，回到首页点击右上方的控制台，进入后点击上方导航栏的产品与服务，然后选择域名，点击进入域名解析列表，然后就可以看到刚刚买的域名了，接下来进行解析配置绑定。 绑定域名 获取自己博客站点IP 1ping username.githhub.io 进入域名解析列表并对购买的域名进行解析。 解析配置好了以后，登录github，进入到博客站点对应的仓库，对域名进行设置： 到这儿还没结束，在你的本地博客站点路径下的source文件夹里，创建一个名为CNAME的文件（注意要大写无后缀名），里面写上你之前购买的域名。 在这个过程中发现了http和https登录本地及GitHub端存在差异。HTTP与HTTPS的差异GitHub下个人博客域名完美支持httpshexo高阶教程 hexo上云 hexo部署到阿里云空间 将hexo部署到云主机 ssh远程登录等等，你以为到这就完了，这也太简单点了吧！这不快过年了吗？作为一个一天不看点教程写点代码写点总结的伪code，总感觉差点什么？这就是事件驱动型，需求出来了，换了电脑怎么写博客。一番baidu、google操作后，大概就是如下几种方法：1、参照如何搭建博客一文在电脑上搭建环境，将以前的博客站点下的source,themes,_config.yml文件复制替换掉新博客的相同文件。2、这个有点复杂呀，设计git的分支知识，我也不是太清楚。3、这个就又上一层楼喽，眼看他起高楼。Hexo版本控制及集成开发我也就按第一种来咯，简单就是一种美呀！其实是其他两种我不会。。。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用]]></title>
    <url>%2F2018%2F02%2F04%2FGit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[学习git使用好久了，好多知识点没用都忘记了。好记忆不如烂笔头，实践才是检验真理的唯一标准。这不，几天前刚学了关于在python中使用OpenCv对图片进行清晰度分辨，正好可以练一下手呀！好在软件有台电脑就可以折腾！废话不多说，开干！！！ 安装git安装及配置git要想使用git必须先下载安装吧！安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！安装完成后，还需要最后一步设置，在命令行输入：12$ git config --global user.name "Your Name"$ git config --global user.email "email@example.com" 创建git版本库什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。所以，创建一个版本库非常简单.首先，选择一个合适的地方，创建一个空目录： 1234$ mkdir learngit$ cd learngit$ pwd #pwd命令用于显示当前目录。/Users/michael/learngit 第二步，通过git init命令把这个目录变成Git可以管理的仓库123$ git init #在目标目录下执行git init将此目录初始化为一个Git仓库。$ find . -name ".git" | xargs rm -Rf #在仓库路径下执行次命令可删除本地git仓库Initialized empty Git repository in /Users/michael/learngit/.git/ 把文件添加到版本库把一个文件放到Git仓库只需要两步第一步，用命令git add告诉Git，把文件添加到仓库：1$ git add readme.txt 第二步，用命令git commit告诉Git，把文件提交到仓库：1234$ git commit -m "wrote a readme file" # -m后面输入的是本次提交的说明[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 添加ssh keys世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 第一步，注册GitHub账号第二步，配置ssh key传输第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有&lt;font color=#0099ff size=4&gt;id_rsa&lt;/font&gt;和&lt;font color=#0099ff size=4&gt;id_rsa.pub&lt;/font&gt;这两个文件， 如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1$ ssh-keygen -t rsa -C "你GitHub上绑定的邮箱" 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： ![看见我你就输了](Git-Usage-Method/0.png) 点“Add Key”，你就应该看到已经添加的Key： ![看见我你就输了](Git-Usage-Method/1.png) 添加远程仓库及提交首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令(关联仓库)：12$ git remote add origin git@github.com:path/repo-name.git$ git remote rm origin #解除远程仓库绑定 提示origin存在可git remote rm origin先移除在git下一步，就可以把本地库的所有内容推送到远程库上：123456789$ git push -u origin masterCounting objects: 19, done.Delta compression using up to 4 threads.Compressing objects: 100% (19/19), done.Writing objects: 100% (19/19), 13.73 KiB, done.Total 23 (delta 6), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git * [new branch] master -&gt; masterBranch master set up to track remote branch master from origin. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。当GitHub页面中看到远程库的内容已经和本地一模一样后。从现在起，只要本地作了提交，就可以通过命令：1$ git push origin master 现在，你就拥有了真正的分布式版本库！ 开始提交到github提交到github过程中反复出现1Writing object: 50%(8/16), 1.24 MiB | 6.00KiB/s 就一直停滞不前，好不容易到了90%，冒出了fatal: The remote end hung up unexpexted fatal错误开始以为是git环境有问题，网络卡的问题，反复尝试多次，依然不行，在网上找了各种方法，提到过提交内容太大git缓冲区太低的问题，但是自己没有敏锐的察觉问题. 其次要把问题现象截图下来，好分析问题，不至于在后面查找问题的过程中忘记问题本省。在这个问题上浪费了大量时间，真的只有踏过的坑多了才能游刃有余呀！ 克隆12345$ git clone https://github.com/miguelgrinberg/flasky.git #从github上克隆项目$ git checkout 1a #切换到1a的版本下$ git reset --hard # 重置本地修改记录$ git fetch --all # 匹配远程仓库的标签$ git diff 2a 2b #查看2a和2b两个版本的区别 常用命令1234567891011$ git status #查看仓库当前状态$ git diff xx.txt #查看修改$ git log #查看提交历史$ git log --pretty=oneline #简化输出$ git reflog #查看命令历史$ git reset --hard commit id #返回指定版本$ git status #查看当前工作区状态$ git checkout --file #把file文件在工作区的修改全部撤销$ git reset HEAD file #撤销暂存区$ cat file #查看文件内容$ git re file #删除文件 github中的watch、star、fork的作用 总结1、安装及配置git，创建本地仓库git init;git add file.name;git commint -m ‘####’.2、注册GitHub账号及添加SSK keys3、GitHub上创建同名仓库;git remote add origin git@github.com:path/repo-name.git;git push -u origin master;git push origin master。Bash下切换盘符 eg: $ cd f:返回上一级 eg: $ cd .. #cd后面有一个空格]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jupyer]]></title>
    <url>%2F2018%2F02%2F04%2FJupyer%2F</url>
    <content type="text"><![CDATA[Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。Jupyter Notebook 的本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。用途包括：数据清理和转换，数值模拟，统计建模，机器学习等等。 Windows下的Jupyter Notebook安装与自定义启动我的路径 C:\Users\Administrator.U0MU2MJDDHTGZAL\AppData\Local\Programs\Python\Python35-32\ScriptsJupyter notebook安装及初步使用Jupyter notebook入门教程（上） 1、pip install jupyter 2、&gt;&gt;&gt;jupyter notebook(命令行) 3、配置Jupyter notebook &gt;&gt;&gt;jupyter notebook --generate-config 修改jupyter_notebook_config.py文件 基本单元(cell),cell类型]]></content>
      <categories>
        <category>视野</category>
      </categories>
      <tags>
        <tag>厚积薄发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wechat autojump]]></title>
    <url>%2F2018%2F02%2F03%2Fautojump%2F</url>
    <content type="text"><![CDATA[Wechat_AutoJumpTensorflow安装tensorflow,那叫一个坑啊！ 总结，tensorflow的安装： 源码安装，需要面对的问题比较多，但是可以接触到更多的实现上的技术细节，掌握的技术也会多很多。但是，条件不允许的情况下，要学会平衡选择。 python的资源，通过yum或pip，非常容易获取，基于套件的安装，要善于分析日志输出信息，善于利用python的资源。]]></content>
      <tags>
        <tag>python example</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openvc和Python对汪星人图像做模糊检测]]></title>
    <url>%2F2018%2F02%2F03%2Fopenvc%E5%92%8CPython%E5%AF%B9%E6%B1%AA%E6%98%9F%E4%BA%BA%E5%9B%BE%E5%83%8F%E5%81%9A%E6%A8%A1%E7%B3%8A%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[[Tensorflow]谷歌第二代人工智能学习系统(http://wiki.jikexueyuan.com/project/tensorflow-zh/)哎！人生最痛苦的莫过于在成长过后才认识到自己能够做什么。学好一项技能最好是时刻是有人养你的时候。也许这就是人生的魅力吧！留有遗憾却不断奋斗。任何时代都要善于抓住机会，善用工具。 开始折腾 Windows下Python安装OpenCV详细步骤如何安装python及第三方包安装OpenCV前需安装Numpy当pip命令无效时可下载对应的.whl文件,cd到.whl文件下pip install xx-xx.whl文件即可(注意python版本及系统对应)简介Opencv在Python中的使用123456789101112131415161718192021222324252627282930313233343536373839404142#import the necessary packagesfrom imutils import psthsimport argparseimport cv2def variance_of_laplacian(image): #此函数只接受一个待计算清晰度评价的image参数(假设是单通道图像，例如灰度图)#compute the Laplacian of the image then return the foucs#measure whith is simply the variance of the Laplacian return cv2.Laplaction(image,cv2.CV_64F).var() #对image用3*3拉普拉斯算子做卷积，然后返回方差。 #construct the argument parse and parse the argumentsap = argparse.ArgumentParse()ap.add_argument('-i','--image',required=True,help = 'path to input directory of images')ap.add_argument('-t','--threshold',type=float,default=100.0,help='focus measures that fall below this value will be considered "blurry"')args = vars(ap.parse_args())#loop over the input imagesfor imagePath in paths.list_image(args['images']): #load the image,convert it to grayscale and compute the #foucs measure of the image using the Variance of Laplacian #method image = cv2.imread(magePath) gray = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY) fm = variance_of_laplacian(gray) text = 'Not Blurry' #if the foucus measure is less than the supplied threshold #then the image should be considered 'blurry' if fm&amp;It;args=['threshold']: text = 'Blurry' #show the image cv2.putText(image,'&#123;&#125;:&#123;:.2f&#125;'.format(text,fm),(10,30), cv2.FONT_HERSHEY_SIMPLEX,0.8,(0,0,255),3) cv2.imshow('image',image) key = cv2.waitKey(0) 完整项目可点我]]></content>
      <tags>
        <tag>python example</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yield]]></title>
    <url>%2F2018%2F02%2F01%2Fyield%2F</url>
    <content type="text"><![CDATA[yieldyield的英文单词意思是生产重要概念 yield表达式，yield表达式参数，yield表达式返回值，next()与send(msg)的返回值 包含yield的函数假如你看到某个函数包含了yield,这意味着这个函数已经是一个Genertor,它的执行会和其他函数有很多不同。123456def h(): print('study yield') yield 5 print('go on!') &gt;&gt;&gt;h() 调用h()后，print语句并没有执行！这就是yield. yield是一个表达式1m = yield 5 yield 5是一个表达式,yield为关键字，5为表达式的参数表达式(yield 5)的返回值将赋值给m，如何获取(yield 5)的返回值，需要用到send(msg). yield工作原理通过next()恢复Generator执行，直到下一个yield；当我们再次调用next()时，会继续执行，直到找到下一个yield。当后面没有yield时，会抛出异常。 send(msg)与next()send()可以传递yield表达式的返回值next()只能传递None所以next()和send(None)作用是一样的 注意生成器刚启动时(第一次调用)，请使用next()语句或是send(None),不能直接发送一个非None的值，否则会报TypeError，因为没有yield语句来接收这个值。 send(msg)与next()的返回值 send(msg)与next()的返回值比较特殊，是下一个yield表达式的参数(yield 5,则返回5)。 1234567891011121314 def s(): print('study yield') m = yield 5 print(m) d = yield 6 print('go on!') &gt;&gt;&gt; c = s()&gt;&gt;&gt;s_d1 = next(c) #相当于send(None)study yield&gt;&gt;&gt;s_d2 = c.send('Fighting!') #yield 5(当前停止的yield表达式)被赋予了'Fighting'Fighting!&gt;&gt;&gt;print('My Birth Day:', s_d1,'.',s_d2)My Birth Day: 5 . 16]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[灵感]]></title>
    <url>%2F2018%2F01%2F30%2Fchongai%2F</url>
    <content type="text"><![CDATA[搭建一个宠物选秀网站—-宠爱搭建一个声音搞笑微信小程序–声旺生物结合编程租房支付平台]]></content>
      <tags>
        <tag>Light and light</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实战总结]]></title>
    <url>%2F2018%2F01%2F24%2F%E5%AE%9E%E6%88%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[day-5 关于python中inspect模块的一些探究]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web]]></title>
    <url>%2F2018%2F01%2F15%2Fweb%2F</url>
    <content type="text"><![CDATA[web框架，看了几遍还是不清楚工作流程，还是要看一下大神的解析。Python廖雪峰实战web开发详解WEB端开发 aiohttp框架处理URL函数过程：第一步，添加协程装饰器12async def handle_url_xxx(request): pass 第二步，对request参数进行操作，以获取相应的参数12url_param = request.math_info['key']query_params = parse_qs(requset.query_string) 第三步，构建Response对象并返回12text = rander('templete',data)return web.Response(text.encode('utf-8')) 自定义Web框架思路:利用@get和@post将一个函数映射为一个URL处理函数; URL处理函数不一定是一个coroutine,使用RequestHandler()来封装一个URL处理函数; 再编写一个add_route函数，注册一个URL处理函数; 接下来，将多册的add_route()注册调用变成自动扫描； 最后在app.py中加入middleware、jinja2模板和自注册的支持. 具体实现:@get和@post(把一个函数映射为一个URL处理函数)定义RequestHandler(URL处理函数不一定是一个coroutine，因此我们用RequestHandler()来封装一个URL处理函数。最后调用URL函数时，会返回一个APIError的错误，在day10) 编写add_route函数及批量处理add_routes()函数（用来注册一个URL处理函数，主要起验证函数是否有包含URL的响应方法与路径信息，以及将函数变为协程。）编写添加静态文件add_static()函数编写初始化jinja2模板init_jinja2()函数编写middlewaremiddleware是一种拦截器，一个URL在被某个函数处理前，可以经过一系列的middleware的处理。一个middleware可以改变URL的输入、输出，甚至可以决定不继续处理而直接返回。middleware的用处就在于把通用的功能从每个URL处理函数中拿出来，集中放到一个地方。 例如，一个记录URL日志的logger可以简单定义如下：123456789@asyncio.coroutine def logger_factory(app, handler): @asyncio.coroutine def logger(request): # 记录日志: logging.info('Request: %s %s' % (request.method, request.path)) # 继续处理请求: return (yield from handler(request)) return logger]]></content>
      <tags>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python mysql]]></title>
    <url>%2F2018%2F01%2F14%2Fpython-MySql%2F</url>
    <content type="text"><![CDATA[麻蛋，几日不用hexo都忘记了要先进入blog才能执行hexo命令，看来还是要多做笔记呀！ MySQL安装及配置mysql 5.6.36 win7 32位免安装版配置 win10上安装mysql 数据库创建用户和分配权限问题 cmd操作数据库常用命令数据库突然就连不上了，那就看看是怎么回事呗。 cmd命令行操作数据库 如何执行sql脚本 12345678910111213141516171819202122232425262728293031323334#查看数据库、表、数据字段、数据C:\User\xxx\&gt; mysql -u root -p #连接数据库Enter password:mysql&gt; show databases; #查看当前所有的数据库英文状态下mysql&gt; use test; #use 数据库名；选择数据库mysql&gt; show tables; #查看当前数据库所有的表mysql&gt; desc user; #desc 表名;查看某个表名的字段结构 desc=descriptionmysql&gt; select * from 表名; #查询表数据#新建数据库、数据表、数据mysql&gt; create database admin; #create database 数据库名;新建数据库mysql&gt; use admin; mysql&gt; create table one( -&gt; id int(8) not null, -&gt; name char(30) -&gt; ) -&gt; ; #字段用逗号隔开，最后一行不用mysql&gt; insert into one values(1,'lisi');#修改数据表，修改数据1、修改数据表mysql&gt; alter table one add age int(8);mysql&gt; alter table one add hoby char(32) after id;mysql&gt; alter table one add address char(10) first;2、修改数据mysql&gt; update one set name = 'xi' where id = 1;#删除数据库、数据表、数据mysql&gt; drop database try; #删除数据库mysql&gt; drop table user; #删除数据表mysql&gt; delete from 表名 where id=1; #删除数据mysql&gt; eixt;mysql&gt; source F:\hello world\niuzi.sql #mysql执行sql脚本，source file. SQL注入SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。参数化查询解决SQL注入问题 python中安装MySQL驱动python中操作mysql的pymysql模块详解 python使用MySQL数据库 我该如何向非技术人解释SQL注入 12345678910111213141516#!/usr/bin/env python# -*- coding:utf-8 -*-import pymysql#创建连接conn = pymysql.connect(user='root',password='password',db='test')#创建游标cursor = conn.cursor()#执行SQL，并打印结果：cursor.execute('select * from one')#打印查询结果：print(cursor.fetchall())#关闭游标cursor.close()#关闭连接conn.close()]]></content>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思考]]></title>
    <url>%2F2018%2F01%2F01%2F%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[早上醒来，已经到了2019.1.1，卧槽我已经毕业三年半了，不由的一股焦虑感涌上心头。三年多了，好像也没有什么成就，技能没有提升，依然单身（ps:从来就么有过对象好不）。孤单迷茫依然萦绕在心头，对生活好像总是提不起兴趣。在这一年里，经历了很多，从年初就一路坎坷，走的很慢很累很痛。有时候想大哭一场却又感觉哭不出来。在这段挫败的日子里也有了很多思考，仿佛把前面20多年欠下的思考全都一次性思考完了。回想前面的20多年，好像一直在浑浑噩噩的度过，从来没想过未来，感觉未来离自己很远。突然间未来已来，自己却不知所措，跌跌撞撞走了三年多，不断折腾生活，心累了，好乱不知道到底在干什么。总的来说这一年确定了自己未来的方向，接触了一些新事物（比特币），改变的自己以前的一些偏执想法，更能拥抱新事物了，对一些人和事更包容了。新的一年里也没有什么大的愿望，只是希望家人健康，快乐幸福就好吧。自己也可以早日实现自己的目标。就这样紫了。孩子快醒醒哈哈哈，今天是2018.1.1.我又年轻了一岁。幸福来得就是这么突然。]]></content>
      <tags>
        <tag>人生</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础概念]]></title>
    <url>%2F2017%2F12%2F30%2F%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[第三方模块由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：在bytes中，无法显示为ASCII字符的字节，用\x##显示。1234&gt;&gt;&gt; 'ABC'.encode('ascii')b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\xe4\xb8\xad\xe6\x96\x87' 123456789101112131415161718192021222324252627&lt;font color=#0099ff size=4&gt;格式化&lt;/font&gt;最后一个常见的问题是如何输出格式化的字符串。在Python中，采用的格式化方式和C语言是一致的，用%实现默认参数一定要用不可变对象，如果是可变对象，程序运行会存在逻辑错误。def add_end(L=[]): L.append('END') return L 可变参数将传入参数自动封装为一个tuple.&gt;&gt;&gt;args = [1,2,3]&gt;&gt;&gt;calc(*args)14*args表示把args这个list的所有元素作为可变参数传进去。**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict关键字参数将传入参数自动封装为一个dict.命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。命名关键字参数&lt;font color=#0099ff size=4&gt;必须&lt;/font&gt;传入参数，可变参数和关键字参数可以不传入参数。def person(name,age,*,city='Beijing',job): print(name,age,city,job) &gt;&gt;&gt;person('Jack',24,job='Enginer')Jack 24 Beijing Engineer 在Python中，这种一边循环一边计算的机制，称为生成器：generator。 generator保存的是算法，每次调用next(g)，就计算出g的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator.可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator 变量可以指向函数函数名也是变量 1234567891011121314def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sum&gt;&gt;&gt; f = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt; &gt;&gt;&gt; f()25 我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。 1234567891011121314151617181920def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count()你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是：&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9全部都是9！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。 这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。本质上，decorator就是一个返回函数的高阶函数。 作用域类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名； 类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等； 之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。1234567891011def _private_1(name): return 'Hello, %s' % namedef _private_2(name): return 'Hi, %s' % namedef greeting(name): if len(name) &gt; 3: return _private_1(name) else: return _private_2(name) 我们在模块里公开greeting()函数，而把内部逻辑用private函数隐藏起来了，这样，调用greeting()函数不用关心内部的private函数细节，这也是一种非常有用的代码封装和抽象的方法，即： 外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public. 面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。### 面向对象编程面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。面向对象设计的程序的执行就是一系列消息在各个对象之间传递。面向对象的设计思想是抽象出Class，根据Class创建Instance.面向对象的抽象程度又比函数要高，因为一个Class既包含数据(Propery)，又包含操作数据的方法(Method)。数据封装、继承和多态是面向对象的三大特点面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板在Class内部，可以有属性(Property)和方法(Method)，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑### 继承和多态这就是著名的“开闭”原则：对扩展开放：允许新增Animal子类；对修改封闭：不需要修改依赖Animal类型的runtwice()等函数。静态语言 vs 动态语言对于静态语言（例如Java）来说，如果需要传入Animal类型，则传入的对象必须是Animal类型或者它的子类，否则，将无法调用run()方法。对于Python这样的动态语言来说，则不一定需要传入Animal类型。我们只需要保证传入的对象有一个run()方法就可以了：123class Timer(object): def run(self): print('Start...')这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。### 获取对象信息使用type()type()函数返回的是什么类型呢？它返回对应的Class类型。如果我们要在if语句中判断，就需要比较两个变量的type类型是否相同判断一个对象是否是函数怎么办？可以使用types模块中定义的常量使用isinstance()总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。使用dir()仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态### 类属性12345678910111213141516&gt;&gt;&gt; class Student(object):... name = 'Student'...&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性Student&gt;&gt;&gt; s.name = 'Michael' # 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student### 使用\_slots__但是，如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：12class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的：对于类的方法，装饰器一样起作用。Python内置的@property装饰器就是负责把一个方法变成属性调用的：12345678910111213141516171819202122class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value &gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()60&gt;&gt;&gt; s.score = 9999Traceback (most recent call last): ...ValueError: score must between 0 ~ 100!Ostrich除了继承自Bird外，再同时继承Runnable。这种设计通常称之为MixIn。为了更好地看出继承关系，我们把Runnable和Flyable改为RunnableMixIn和FlyableMixIn.Python的class允许定义许多定制方法，可以让我们非常方便地生成特定的类。__str__ __iter__ __getitem__ __getattr__ __call__本节介绍的是最常用的几个定制方法，还有很多可定制的方法，请参考Python的官方文档### 枚举Enum枚举成员，枚举的名称，成员值### 使用元类type()动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类，而无需通过class Hello(object)…的定义：1234567891011&gt;&gt;&gt; def fn(self, name='world'): # 先定义函数... print('Hello, %s.' % name)...&gt;&gt;&gt; Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class&gt;&gt;&gt; h = Hello()&gt;&gt;&gt; h.hello()Hello, world.&gt;&gt;&gt; print(type(Hello))&lt;class 'type'&gt;&gt;&gt;&gt; print(type(h))&lt;class '__main__.Hello'&gt;要创建一个class对象，type()函数依次传入3个参数： 1、class的名称； 2、继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法； 3、class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。metaclass我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法：定义ListMetaclass，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：123456789101112131415161718192021222324252627# metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs) class MyList(list, metaclass=ListMetaclass): pass当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过ListMetaclass.__new__()来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。__new__()方法接收到的参数依次是： 1、当前准备创建的类的对象； 2、类的名字； 3、类继承的父类集合； 4、类的方法集合。测试一下MyList是否可以调用add()方法：&gt;&gt;&gt; L = MyList()&gt;&gt;&gt; L.add(1)&gt;&gt; L[1]你不知道的super()事实上，对于你定义的每一个类，Python 会计算出一个方法解析顺序（Method Resolution Order, MRO）列表，它代表了类继承的顺序,我们可以使用下面的方式获得某个类的 MRO 列表：12&gt;&gt;&gt; C.mro() # or C.__mro__ or C().__class__.mro()[__main__.C, __main__.A, __main__.B, __main__.Base, object]super 的工作原理如下：123def super(cls, inst): mro = inst.__class__.mro() return mro[mro.index(cls) + 1]其中，cls 代表类，inst 代表实例，上面的代码做了两件事： 1、获取 inst 的 MRO 列表 2、查找 cls 在当前 MRO 列表中的 index, 并返回它的下一个类，即 mro[index + 1]当你使用 super(cls, inst) 时，Python 会在 inst 的 MRO 列表上搜索 cls 的下一个类。那这个 MRO 列表的顺序是怎么定的呢，它是通过一个 C3 线性化算法来实现的### IO编程input/output是相对于内存来说的。IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。同步和异步的区别就在于是否等待IO执行的结果异步IO的缺点是编程模型复杂，方法也各不相同，有回调模式和轮询模式。操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用#### 文件读写在Python中，文件读写是通过open()函数打开的文件对象完成的。12with open('/path/to/file', 'r') as f: print(f.read())使用with语句操作文件IO是个好习惯。f = open(‘/Users/michael/gbk.txt’, ‘r’, encoding=’gbk’, errors=’ignore’)### StringIO和BytesIO很多时候，数据读写不一定是文件，也可以在内存中读写。StringIO顾名思义就是在内存中读写str。要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：12345678910&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO() #创建文件对象&gt;&gt;&gt; f.write('hello') #执行写命令5&gt;&gt;&gt; f.write(' ')1&gt;&gt;&gt; f.write('world!')6&gt;&gt;&gt; print(f.getvalue())hello world!StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\xe4\xb8\xad\xe6\x96\x87'StringIO和BytesIO是在内存中操作str和bytes的方法，使得和读写文件具有一致的接口。#### 操作文件和目录Python的os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在os.path模块中。操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：12345678910# 查看当前目录的绝对路径:&gt;&gt;&gt; os.path.abspath('.')'/Users/michael'# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:&gt;&gt;&gt; os.path.join('/Users/michael', 'testdir')'/Users/michael/testdir'# 然后创建一个目录:&gt;&gt;&gt; os.mkdir('/Users/michael/testdir')# 删掉一个目录:&gt;&gt;&gt; os.rmdir('/Users/michael/testdir')&gt;&gt;&gt; os.path.split(‘/Users/michael/testdir/file.txt’)(‘/Users/michael/testdir’, ‘file.txt’)这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。 序列化Python序列化和反序列化序列化与编码我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 Python提供了pickle模块来实现序列化。1234&gt;&gt;&gt; import pickle&gt;&gt;&gt; d = dict(name='Bob', age=20, score=88)&gt;&gt;&gt; pickle.dumps(d)b'\x80\x03&#125;q\x00(X\x03\x00\x00\x00ageq\x01K\x14X\x05\x00\x00\x00scoreq\x02KXX\x04\x00\x00\x00nameq\x03X\x03\x00\x00\x00Bobq\x04u.' JSON更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取. Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：1234&gt;&gt;&gt; import json&gt;&gt;&gt; d = dict(name='Bob', age=20, score=88)&gt;&gt;&gt; json.dumps(d)'&#123;"age": 20, "score": 88, "name": "Bob"&#125;' dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。 进程和线程对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。 有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。 多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。 多进程multiprocessing模块提供了一个Process类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：1234567891011121314from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name): print('Run child process %s (%s)...' % (name, os.getpid()))if __name__=='__main__': print('Parent process %s.' % os.getpid()) p = Process(target=run_proc, args=('test',)) print('Child process will start.') p.start() p.join() print('Child process end.') 执行结果如下：1234Parent process 928.Process will start.Run child process test (929)...Process end. 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。 join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。 Pool 子进程 进程间通信进程间通信是通过Queue、Pipes等实现的。 一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。 对应到Python语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面讨论如何编写协程。 网络通信是两台计算机上的两个进程之间的通信.比如，浏览器进程和新浪服务器上的某个Web服务进程在通信，而QQ进程是和腾讯的某个服务器上的某个进程在通信。 分布式进程在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。Python的multiprocessing模块不但支持多进程，其中managers子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于managers模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。 正则表达式正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。 break在循环中，break语句可以提前退出循环。例如，本来要循环打印1～100的数字：12345n = 1while n &lt;= 100: print(n) n = n + 1print('END') 上面的代码可以打印出1~100。 如果要提前结束循环，可以用break语句：1234567n = 1while n &lt;= 100: if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1print('END') 执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束。 可见break的作用是提前结束循环。12if not data or data.decode('utf-8')=='exit':#先计算not data是True还是False然后求与 break WSGI了解了HTTP协议和HTML文档，我们其实就明白了一个Web应用的本质就是： 1.浏览器发送一个HTTP请求； 2.服务器收到请求，生成一个HTML文档； 3.服务器把HTML文档作为HTTP响应的Body发送给浏览器； 4.浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。 如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。 正确的做法是底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，需要一个统一的接口，让我们专心用Python编写Web业务。 这个接口就是WSGI：Web Server Gateway Interface。 WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。我们来看一个最简单的Web版本的“Hello, web!”：123def application(environ, start_response): start_response('200 OK', [('Content-Type', 'text/html')]) return [b'&lt;h1&gt;Hello, web!&lt;/h1&gt;'] 上面的application()函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数： environ：一个包含所有HTTP请求信息的dict对象； start_response：一个发送HTTP响应的函数。 在application()函数中，调用：1start_response('200 OK', [('Content-Type', 'text/html')]) 就发送了HTTP响应的Header，注意Header只能发送一次，也就是只能调用一次start_response()函数。start_response()函数接收两个参数，一个是HTTP响应码，一个是一组list表示的HTTP Header，每个Header用一个包含两个str的tuple表示。 通常情况下，都应该把Content-Type头发送给浏览器。其他很多常用的HTTP Header也应该发送。 然后，函数的返回值b’Hello, web!‘将作为HTTP响应的Body发送给浏览器。 有了WSGI，我们关心的就是如何从environ这个dict对象拿到HTTP请求信息，然后构造HTML，通过start_response()发送Header，最后返回Body。 整个application()函数本身没有涉及到任何解析HTTP的部分，也就是说，底层代码不需要我们自己编写，我们只负责在更高层次上考虑如何响应请求就可以了。 不过，等等，这个application()函数怎么调用？如果我们自己调用，两个参数environ和start_response我们没法提供，返回的bytes也没法发给浏览器。 所以application()函数必须由WSGI服务器来调用。有很多符合WSGI规范的服务器，我们可以挑选一个来用。但是现在，我们只想尽快测试一下我们编写的application()函数真的可以把HTML输出到浏览器，所以，要赶紧找一个最简单的WSGI服务器，把我们的Web应用程序跑起来。 好消息是Python内置了一个WSGI服务器，这个模块叫wsgiref，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。 web 框架除了Flask，常见的Python Web框架还有： Django：全能型Web框架； web.py：一个小巧的Web框架； Bottle：和Flask类似的Web框架； Tornado：Facebook的开源异步Web框架。 当然了，因为开发Python的Web框架也不是什么难事，我们后面也会讲到开发Web框架的内容。 模板使用模板，我们需要预先准备一个HTML文档，这个HTML文档不是普通的HTML，而是嵌入了一些变量和指令，然后，根据我们传入的数据，替换后，得到最终的HTML，发送给用户： 因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。 asyncio可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把asyncio用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+coroutine实现多用户的高并发支持。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[decorator]]></title>
    <url>%2F2017%2F12%2F30%2Fdecorator%2F</url>
    <content type="text"><![CDATA[函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。123456&gt;&gt;&gt; def now():... print('2015-3-25')...&gt;&gt;&gt; f = now #now只是指向now()函数并不是调用函数&gt;&gt;&gt; f()2015-3-25 在函数调用前后自动打印日志，但又不希望修改now()函数的定义，增强now()函数的功能，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。本质上，decorator就是一个返回函数的高阶函数。 我们要定义一个能打印日志的decorator，可以定义如下：12345def log(func): def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper 观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：123@logdef now(): print('2015-3-25') 调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志： 123 &gt;&gt;&gt; now() #相当于先执行now=log(now),在运行now()返回函数。call now():2015-3-25 把@log放到now()函数的定义处，相当于执行了语句：now = log(now)由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。 wrapper()函数的参数定义是(args, *kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[返回函数]]></title>
    <url>%2F2017%2F12%2F27%2F%E8%BF%94%E5%9B%9E%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[返回函数好复杂呀!123456789def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count() 单独执行f1 = count()然后执行f1()竟然会报错，我的天呀，怎么理解！！！ 知乎黄光星 我觉得文中的例子对初学者不太友好，里面同时混杂几个不同的问题。因为涉及问题太多了，我也不期待能够一下说明白，尽力而为。（1）unpack tuple和list, 可以让函数返回多个值1234567def count(): return (1, 2, 3) # 或者 return [1, 2, 3]# 把列表解包，把1 2 3 分别赋值给 a b ca, b, c = count()print a, b, c# 输出 1, 2, 3 （2）假设你知道Python的dict类型。Python中，在函数中定义一个变量的时候，会在一个隐藏的叫locals的dict里面插入key-value，其中key是变量名，value是变量值。而引用一个变量的时候，则首先会在这个叫locals的dict里面，根据变量名作为key，去查对应的值。12var = 1 # 你可以认为这里进行了 locals['var'] = 1 的操作print var # 在对var变量进行求值的时候，就在locals['var']里面找var变量对应的值 （3）for循环中，每次循环只是给 i 重新绑定值12345for i in (1, 2, 3): print iprint i# 一次输入 1 2 3 3 每次for i in (1, 2, 3)相当于在print i之前，进行了locals[&#39;i&#39;] = 1locals[&#39;i&#39;] = 2locals[&#39;i&#39;] = 3的操作所以最后的print i再去locals字典里面找i的时候，就变成 3 了。（4）闭包是 一个函数加上这个函数引用的外部变量123456789101112var = 1def f(): print var# 这里的闭包是函数 f 和 f 引用的外部变量 vardef count(): var2 = 2 def f(): print var2 # 这里的闭包是函数 f 和 f 引用的外部变量 var2 return f 拿第一个函数 f 来说。在 f 运行的时候，解释器拿着’var’这个字符串去locals字典里面找，发现找不到，于是在closure字典里面找，最后closure字典里面找，你可以认为就是找closure[‘var’]，然后发现找到对应的值。count里面的 f 函数同理。（为了容易理解，我这里说谎了。实际上 f 压根没有closure，count里面的 f 才有。其实closure压根不是像locals那样的字典）（5）函数定义时，函数只是记录变量的名字。要区分什么是名字，什么是值。i = 1这里 i 只是名字，只是一个字符串 ‘i’ 。这句话运行完，locals[‘i’] = 1，就说 i 对应的值是1.123456789101112131415161718192021222324def count(): fs = [] for i in range(1, 4): # 定义一个函数，等价于运行了 locals['f'] = 真正生成的函数 # 每次循环，这里都会重新生成一个函数，然后把重新生成的函数赋值给 locals['f'] def f(): return i * i # 引用了'i'这个名字，但并不是引用了'i'对应的值 # 等价于 locals['fs'].append(locals['f']) # f 不是函数，它只是一个名字'f'。f 引用的东西，也就是locals['f']才是真正的函数 fs.append(f) # 于是这个for循环生成了三个函数，这三个函数是没有名字的，这个函数运行完后，它们跟'f'这个名字就毛关系都没有了(是的我说慌了，但可以先不管) # 把整个列表返回，这个列表包含了三个函数 return fs# count()返回三个函数的列表，unpack 列表的语法把列表中的三个函数抽出来，重新给他们命名为 f1, f2, f3# 也就是说，# locals['f1'] = 列表中的第1个函数# locals['f2'] = 列表中的第2个函数# locals['f3'] = 列表中的第3个函数# 这三个函数跟'f'这个名字现在毛关系都没有。（其实是有的，但为了说明需要简化，现在你可以完全不管括号里面说的话）f1, f2, f3 = count()print f1(), f2(), f3()# 好了我们运行它们，输入都是 9 def f(): return i * i这是因为 f1 现在对应的函数，里面引用了 ‘i’ 这个字符串，我们根据 ‘i ‘这个字符串去找它对应的值，先找到 f 当前的locals字典，发现没有，因为函数定义的时候没有定义 i 变量。然后再去closure[‘i’]里面找，因为Python是通过closure字典实现闭包的（就当它是对的好不好），所以我们可以在closure[‘i’]找到值，这个值就是我们上一次运行的时候count函数里面残留的locals[‘i’]，而由于for循环三遍之后，locals[‘i’] == 3，所以找到 i 的值就是3。所以最后输出都是9 小结一个函数可以返回一个计算结果，也可以返回一个函数。 返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用网址]]></title>
    <url>%2F2017%2F12%2F24%2F%E5%B8%B8%E7%94%A8%E7%BD%91%E5%9D%80%2F</url>
    <content type="text"><![CDATA[缘起我就是有一个烦恼呀，有时候用过的好的网站喜欢保存下来，这样下次用的时候就不会想不起来了。虽说浏览器可以设置收藏栏，但只能局限于本机。在其他机器上就看不到了。这不，前几天搭建了自己的简易博客，可以通过博客写一篇常用网址，不就可以随时随地的查看了。说干就干！ 常用网址看电影 电影天堂天天影院看天堂BT MOS管原理用法 好的个人网站 廖雪峰崔庆才潘柏信王雨城林夕水共phodal零尾deep learning我的github肖泰洪资深coder池建强不知道叫什么折腾一个妹子的博客 好的学习网站 简书知乎玩蛇网牛客网Hexo巴比特sosobtc 问题解决网站 StackOverFlow栈溢出SegmentFaultFunDebug]]></content>
      <tags>
        <tag>厚积薄发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[api]]></title>
    <url>%2F2017%2F12%2F23%2Fapi%2F</url>
    <content type="text"><![CDATA[API是什么？ 有人会吗？]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于如何基于hexo+github搭建自己的博客总结]]></title>
    <url>%2F2017%2F12%2F23%2F%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8Ehexo-github%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[初见一日早上在拥挤的深圳地铁上，人挤人总不能发呆吧！浪费时间是可耻的，总该做点什么不是吗？这不，拿出手机打开微信，订阅号中“hexo+github搭建个人博客（小白篇）”一下吸引了我。啥github?不是最近我玩过的那个吗？不不不！是小白，小白不就是我吗？我是小白，我怕谁。 兄弟不要怂，就是干!!!在度娘的帮助下了解了啥是hexo,经历本地端口4000被占用.PS:为啥就么有人把4000这个常见端口改成其他的，不要让尔等小白一上来就懵逼。 hexo d 无反应，卡了一天多。最终按照这样写的123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:luckyki/luckyki.github.io.git branch: master 在解决这些问题的过程中也发现了如下这些优秀博客Litten用github+hexo搭建你的博客潘柏信在他们的博客帮助下终于搭建了自己的第一个博客。点我查看比较简陋，多多理解。这样就完了吗？电影可不是这样结尾的哟！肯定得接着搞事情了更换主题，修改图像，插入图片，写第一篇博文，这不，你看的就是我。后续会跟着大神继续学习，绑定域名，….目前只知道这些了。 Next主题切换hexo.iohexo个人博客切换参照next使用手册Hexo-设置阅读全文leanCloud githubLiveRe 网易邮箱，lbl233]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终于遇见你]]></title>
    <url>%2F2015%2F06%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
